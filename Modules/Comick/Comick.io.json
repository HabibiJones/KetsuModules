{"moduleInfo":{"moduleName":"Comick.io","moduleInitials":"CM","moduleDesc":"To you I bring the goat, Comick","developer":"Scrumptious","moduleID":"20250630","moduleImage":"https://comick.io/static/icons/unicorn-64.png","moduleVersion":1,"moduleLenguage":"ENG","moduleType":"Image","baseURL":"https://comick.io","moduleDeveloperSite":"https://github.com/OffsetParts/KetsuModules/","UpdateSite":"https://raw.githubusercontent.com/OffsetParts/KetsuModules/master/Modules/Comick/Comick.io.json","preferedServer":"","preferedDownloadServer":"","blackListed":[""],"fileType":"moduleInfo","fileSection":"Module","fileID":3955225847,"fileName":"moduleInfo.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":false},"params":{"name":"Settings Editor","route":[],"status":true}},"fileIndexPath":[2,0]},"global":{"variables":[{"key":"","value":""}],"cookies":[{"key":"","value":""}],"headers":[{"key":"","value":""}]},"mainPage":[{"request":{"url":"https://google.com","method":"GET","headers":[{"key":"","value":""}]},"extra":{"commands":[{"commandName":"","params":[{"key":"","value":""}]}],"extraInfo":[{"key":"","value":""}]},"javascriptConfig":{"removeJavascript":true,"loadInWebView":false,"javaScript":"\n            var System = (function() {\n  var modules = {};\n  \n  function register(name, deps, declare) {\n      modules[name] = { deps: deps, declare: declare };\n  }\n  \n  function getModule(name) {\n      var module = modules[name];\n      if (!module) throw new Error('Module ' + name + ' not found');\n      if (module.exports) return module.exports;\n      \n      var exports = {};\n      var context = { id: name };\n      \n      // Create a function to export values\n      function exportFn(key, value) {\n          if (arguments.length === 1) {\n              Object.assign(exports, key);\n          } else {\n              exports[key] = value;\n          }\n      }\n      \n      var setters = [];\n      var depExports = [];\n      \n      // Load dependencies first\n      for (var i = 0; i < module.deps.length; i++) {\n          if (module.deps[i] !== 'exports') {\n              depExports.push(getModule(module.deps[i]));\n          }\n      }\n      \n      // Call the module declaration\n      var declared = module.declare(exportFn, context);\n      \n      // Call setters with loaded dependencies\n      if (declared.setters) {\n          var depIndex = 0;\n          for (var i = 0; i < declared.setters.length; i++) {\n              if (declared.setters[i]) {\n                  declared.setters[i](depExports[depIndex++]);\n              }\n          }\n      }\n      \n      // Execute the module\n      if (declared.execute) {\n          declared.execute();\n      }\n      \n      module.exports = exports;\n      return exports;\n  }\n  \n  return {\n      register: register,\n      import: function(name) { \n          getModule(name);\n      }\n  };\n})();\n\n            System.register(\"core\", [], function (exports_1, context_1) {\n    \"use strict\";\n    var emptyKeyVal, defaultImage, defaultRequest, _metadata, _store, store, _logs;\n    var __moduleName = context_1 && context_1.id;\n    /**\n     * Makes an HTTP request to a website, you can also run javascript directly on the website.\n     * @param url - The URL to fetch\n     * @param options - Fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Simple fetch\n     * const html = await fetch(\"https://example.com\");\n     *\n     * @example\n     * // Fetch and execute code in site context\n     * const result = await fetch(\"https://example.com\", {}, (window) => {\n     *   return window.document.title;\n     * });\n     */\n    async function fetch(url, options = {}, ...run) {\n        let meta = metadata();\n        let metaUrl = meta.request.url;\n        if (url === metaUrl) {\n            let res = run.length > 0 ? await run[0]?.(window) : window.document.documentElement.outerHTML;\n            store.set(url, res);\n            return run.length > 0 ? res : window.document.documentElement;\n        }\n        let cached = store.get(url);\n        if (cached === undefined) {\n            meta.request = request(url, options);\n            meta.javascriptConfig.loadInWebView = options.loadInSite ?? false;\n            meta.javascriptConfig.removeJavascript = options.removeScripts ?? false;\n            return finish();\n        }\n        return (typeof cached === \"string\" && cached.trim().startsWith('<')) ?\n            (new DOMParser()).parseFromString(cached, \"text/html\").documentElement :\n            cached;\n    }\n    exports_1(\"fetch\", fetch);\n    /**\n     * Same as fetch but used on parts of the module where the Request is dynamic, must be used at first of the Info, Chapters and Resolvers scripts.\n     * @param options - Dynamic fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Dynamic fetch with test URL\n     * const result = await dynamicFetch({ testURL: \"https://api.example.com\" });\n     */\n    async function dynamicFetch(_options = {}, ...run) {\n        let meta = metadata();\n        let currentURL = meta.request.url;\n        let url = store.get(\"ketsu_dynamic\");\n        let options = _options;\n        if (options.testURL) {\n            url = options.testURL;\n        }\n        if (!url) {\n            if (!currentURL.includes(\"ketsu_dynamic=\")) {\n                throw new Error(\"No dynamic URL available and no testURL provided.\");\n            }\n            const encoded = currentURL.split(\"ketsu_dynamic=\")[1];\n            const originalRequest = JSON.parse(decodeURIComponent(encoded));\n            url = originalRequest.url;\n            // Merge headers/body/method only if not already defined\n            options.method ?? (options.method = originalRequest.method);\n            options.body ?? (options.body = originalRequest.httpBody);\n            const originalHeaders = Object.fromEntries(originalRequest.headers.map(kv => [kv.key, kv.value]));\n            options.headers = {\n                ...originalHeaders,\n                ...options.headers\n            };\n            // Save resolved URL to prevent repeating decoding later\n            store.set(\"ketsu_dynamic\", url);\n        }\n        return fetch(url, options, ...run);\n    }\n    exports_1(\"dynamicFetch\", dynamicFetch);\n    function toast(text) {\n        action(\"KETSU_MSG\", text);\n    }\n    exports_1(\"toast\", toast);\n    // MARK: REQUEST\n    /**\n     * Creates a request object for KETSU\n     * @param url - The target URL\n     * @param options - Request configuration options\n     * @returns Request object formatted for the Ketsu framework\n     *\n     * @example\n     * const req = request(\"https://api.example.com\", {\n     *   method: \"POST\",\n     *   headers: { \"Content-Type\": \"application/json\" },\n     *   body: JSON.stringify({ data: \"example\" })\n     * });\n     */\n    function request(url, options = {}) {\n        return {\n            url: url,\n            method: options.method || \"GET\",\n            headers: options.headers ? Object.keys(options.headers).map((k) => ({ key: k, value: options.headers?.[k] || \"\" })) : emptyKeyVal,\n            httpBody: options.body\n        };\n    }\n    exports_1(\"request\", request);\n    function dynamicRequest(request) {\n        return {\n            url: `https://google.com/?ketsu_dynamic=${encodeURIComponent(JSON.stringify(request))}`,\n            method: \"GET\",\n            headers: emptyKeyVal,\n            httpBody: undefined\n        };\n    }\n    function viewsHolder(h) {\n        return {\n            cellDesing: h.design || \"wide5\",\n            defaultLayout: h.distribution || \"wideStrechedFullList\",\n            orientation: h.orientation || \"vertical\",\n            section: {\n                sectionName: h.title || \"\",\n                separator: true\n            },\n            paging: \"leading\",\n            data: h.views || [],\n            layout: undefined,\n        };\n    }\n    exports_1(\"viewsHolder\", viewsHolder);\n    /**\n     * Creates a content view with default values\n     * @param v - Partial view configuration\n     * @returns Complete View object with defaults applied\n     *\n     * @example\n     * const movieView = view({\n     *   title: \"The Matrix\",\n     *   description: \"A computer hacker learns about reality\",\n     *   image: request(\"https://example.com/matrix.jpg\"),\n     *   link: request(\"https://example.com/matrix\")\n     * });\n     */\n    function view(v) {\n        return {\n            link: dynamicRequest(v.link || defaultRequest),\n            image: v.image || defaultImage,\n            title: v.title || \"\",\n            description: v.description || \"\",\n            field1: v.field1 || \"\",\n            field2: v.field2 || \"\",\n            field3: v.field3 || \"\",\n            field4: v.field4 || \"\",\n            isChapter: false,\n            openInWebView: false\n        };\n    }\n    exports_1(\"view\", view);\n    // MARK: MAINPAGE\n    /**\n     * Sets up the main page layout with the provided view holders\n     * @param layout - Array of ViewsHolder objects to display on the main page\n     *\n     * @example\n     * main([\n     *   viewsHolder({ title: \"Featured\", views: featuredViews }),\n     *   viewsHolder({ title: \"Popular\", views: popularViews })\n     * ]);\n     */\n    function main(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"main\", main);\n    // MARK: SEARCHPAGE\n    /**\n     * Sets up the search results page layout\n     * @param layout - Array of ViewsHolder objects to display search results\n     *\n     * @example\n     * search([\n     *   viewsHolder({ title: \"Search Results\", views: searchResults })\n     * ]);\n     */\n    function search(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"search\", search);\n    /**\n     * Retrieves current search metadata (query and page), must be used at the start of the search script.\n     * @param test - Optional test metadata to override URL parsing\n     * @returns Search metadata object\n     *\n     * @example\n     * const { searched, page } = searchMetadata();\n     * console.log(`Searching for: ${searched}, Page: ${page}`);\n     */\n    function searchMetadata(test) {\n        let meta = metadata();\n        let searchMeta = store.get(\"ketsu_search\");\n        if (!searchMeta && meta.request.url.includes(\"?ketsu_search=\")) {\n            let url = new URL(meta.request.url).searchParams;\n            let searched = url.get(\"ketsu_search\") || \"\";\n            let page = parseInt(url.get(\"page\") || \"0\", 10);\n            searchMeta = {\n                searched: test?.searched ? test.searched : searched,\n                page: test?.page ? test.page : page\n            };\n            store.set(\"ketsu_search\", searchMeta);\n        }\n        return searchMeta || { searched: \"\", page: 0 };\n    }\n    exports_1(\"searchMetadata\", searchMetadata);\n    /**\n     * Creates a chapter request object\n     * @param url - Chapter URL\n     * @param options - Chapter configuration options\n     * @returns ChapterRequest object\n     *\n     * @example\n     * const chapter = chapterRequest(\"https://example.com/chapter1\", {\n     *   name: \"Chapter 1: The Beginning\",\n     *   openInWebView: false\n     * });\n     */\n    function chapterRequest(url, options = {}) {\n        return {\n            chapName: options.name,\n            link: dynamicRequest(request(url, options)),\n            openInWebView: options.openInWebView ?? false\n        };\n    }\n    exports_1(\"chapterRequest\", chapterRequest);\n    /**\n     * Sets up an information/detail page\n     * @param data - Partial info page configuration\n     *\n     * @example\n     * info({\n     *   title: \" Some title\",\n     *   description: \"A high school chemistry teacher turned meth cook\",\n     *   genres: [\"Drama\", \"Crime\", \"Thriller\"],\n     *   chapters: [chapter1, chapter2, chapter3]\n     * });\n     */\n    function info(data) {\n        let l = {\n            image: data.image || defaultImage,\n            link: data.link || metadata().request,\n            title: data.title || \"\",\n            description: data.description || \"\",\n            genres: data.genres || [],\n            field1: data.field1 || \"\",\n            field2: data.field2 || \"\",\n            field3: data.field3 || \"\",\n            field4: data.field4 || \"\",\n            chapters: data.chapters || []\n        };\n        metadata().output = l;\n        finish();\n    }\n    exports_1(\"info\", info);\n    /**\n     * Sets up chapter content (videos, images, or text)\n     * @param data - Chapter content data (images, videos, or text string)\n     *\n     * @example\n     * // For image-based content (manga)\n     * chapters([\n     *   request(\"https://example.com/page1.jpg\"),\n     *   request(\"https://example.com/page2.jpg\")\n     * ]);\n     *\n     * @example\n     * // For video content\n     * chapters([\n     *   videoRequest(\"https://example.com/video.mp4\"),\n     *   resolverRequest(\"https://example.com/embed\")\n     * ]);\n     *\n     * @example\n     * // For text content\n     * chapters(\"This is the chapter text content...\");\n     */\n    function chapters(data) {\n        let output = {\n            videos: undefined,\n            text: undefined,\n            images: undefined\n        };\n        if (!Array.isArray(data)) {\n            if (typeof data !== \"string\") {\n                throw new Error(\"Chapters type is wrong\");\n            }\n            output.text = { text: data };\n        }\n        if (Array.isArray(data) && data.some((k) => (\"url\" in k))) {\n            output.images = data;\n        }\n        else if (Array.isArray(data)) {\n            output.videos = {\n                needsResolver: [],\n                rawVideo: []\n            };\n            data.forEach((v) => \"video\" in v ? output.videos.rawVideo.push(v) : output.videos.needsResolver.push(v));\n        }\n        metadata().output = output;\n        finish();\n    }\n    exports_1(\"chapters\", chapters);\n    // MARK: RESOLVE\n    /**\n     * Returns the video resolved from the embeded website.\n     * @param video - VideoRequest object to resolve\n     *\n     * @example\n     * const resolvedVideo = videoRequest(\"https://cdn.example.com/video.mp4\");\n     * resolver(resolvedVideo);\n     */\n    function resolver(video) {\n        metadata().output = video;\n        finish();\n    }\n    exports_1(\"resolver\", resolver);\n    /**\n     * Creates a resolver request for extracting video URLs from embed pages\n     * @param url - URL to the video resolver/embed page\n     * @param options - Resolver configuration options\n     * @returns ResolverRequest object\n     *\n     * @example\n     * const resolver = resolverRequest(\"https://streamwebsite.com/video123\", {\n     *   resolverID: \"STREAMWEBSITE\" //\n     * });\n     */\n    function resolverRequest(url, options) {\n        return {\n            link: dynamicRequest(request(url, options)),\n            resolverIdentifier: options?.resolverID || \"\"\n        };\n    }\n    exports_1(\"resolverRequest\", resolverRequest);\n    /**\n     * Creates a subtitle request\n     * @param url - URL to subtitle file\n     * @param options - Subtitle configuration options\n     * @returns SubsRequest object\n     *\n     * @example\n     * const subtitles = subsRequest(\"https://example.com/subs.vtt\", {\n     *   language: \"English\"\n     * });\n     */\n    function subsRequest(url, options) {\n        return {\n            link: request(url, options),\n            language: options?.language || \"unknown\"\n        };\n    }\n    exports_1(\"subsRequest\", subsRequest);\n    /**\n     * Creates a video request with quality and subtitle options\n     * @param url - Direct video URL\n     * @param options - Video configuration options\n     * @returns VideoRequest object\n     *\n     * @example\n     * const video = videoRequest(\"https://example.com/video.mp4\", {\n     *   quality: \"1080p\",\n     *   subs: [\n     *     subsRequest(\"https://example.com/en.vtt\", { language: \"English\" }),\n     *     subsRequest(\"https://example.com/es.vtt\", { language: \"Spanish\" })\n     *   ]\n     * });\n     */\n    function videoRequest(url, options) {\n        return {\n            video: [{\n                    videoLink: request(url, options),\n                    videoQuality: options?.quality || \"auto\"\n                }],\n            subs: options?.subs\n        };\n    }\n    exports_1(\"videoRequest\", videoRequest);\n    function metadata() {\n        if (!_metadata) {\n            const savedData = document.getElementById('ketsu-final-data');\n            _metadata = JSON.parse(savedData?.textContent || \"\");\n        }\n        return _metadata;\n    }\n    // MARK: Finish\n    function finish() {\n        const savedData = document.getElementById('ketsu-final-data');\n        _metadata ? (savedData.textContent = JSON.stringify(_metadata)) : (undefined);\n        _logs.forEach((l) => action(\"KETSU_LOG\", l));\n        action(\"EXECUTE_KETSU_ASYNC\");\n        throw new Error();\n    }\n    function setExtraInfo(key, value) {\n        let meta = metadata();\n        let kv = meta.extra.extraInfo.find((k) => k.key === key);\n        if (!kv) {\n            kv = {\n                key: \"\",\n                value: \"\"\n            };\n            meta.extra.extraInfo.push(kv);\n        }\n        kv.key = key;\n        kv.value = value;\n    }\n    function setCommand(name, key, value) {\n        let meta = metadata();\n        let command = meta.extra.commands.find((c) => c.commandName == name);\n        if (!command) {\n            command = {\n                commandName: name,\n                params: []\n            };\n            meta.extra.commands.push(command);\n        }\n        command.params.push({ key, value });\n    }\n    function action(name, val = \"\") {\n        if (\"webkit\" in window) {\n            window.webkit.messageHandlers[name].postMessage(val);\n        }\n        else if (name === \"KETSU_LOG\") {\n            console.log(val);\n        }\n    }\n    /**\n     * Logs messages for debugging purposes\n     * @param args - Values to log\n     *\n     * @example\n     * log(\"Debug message\", { data: \"example\" });\n     * log(\"User action:\", userAction, \"Result:\", result);\n     */\n    function log(...args) {\n        const stringifiedArgs = args.map(arg => stringify(arg)).join('\\n\\n');\n        _logs.push(stringifiedArgs);\n    }\n    exports_1(\"log\", log);\n    function stringify(value) {\n        // Primitives\n        if (value === null)\n            return 'null';\n        if (value === undefined)\n            return 'undefined';\n        if (typeof value === 'string')\n            return value;\n        if (typeof value === 'number' || typeof value === 'boolean')\n            return String(value);\n        // Functions\n        if (typeof value === 'function') {\n            return `[Function: ${value.name || 'anonymous'}]`;\n        }\n        // Errors\n        if (value instanceof Error) {\n            return `${value.name}: ${value.message}`;\n        }\n        // Everything else - just stringify with pretty print\n        try {\n            return JSON.stringify(value, (key, val) => {\n                if (typeof val === 'function') {\n                    return `[Function: ${val.name || 'anonymous'}]`;\n                }\n                if (val instanceof Error) {\n                    return `${val.name}: ${val.message}`;\n                }\n                return val;\n            }, 2);\n        }\n        catch (e) {\n            return `[${value.constructor?.name || 'Object'}]`;\n        }\n    }\n    return {\n        setters: [],\n        execute: function () {\n            // MARK:GLOBAL\n            window.KETSU_ASYNC = true;\n            emptyKeyVal = [{ key: \"\", value: \"\" }];\n            defaultImage = request(\"https://www.shutterstock.com/image-vector/default-ui-image-placeholder-wireframes-600nw-1037719192.jpg\");\n            defaultRequest = request(\"https://www.google.com/\");\n            _metadata = undefined;\n            _store = {\n                ...[...metadata().extra.extraInfo, ...metadata().global.variables].reduce((acc, val) => {\n                    acc[val.key] = val.value;\n                    return acc;\n                }, {})\n            };\n            /**\n             * Global storage instance for persisting data\n             *\n             * @example\n             * // Store data\n             * store.set(\"user_preferences\", { theme: \"dark\" });\n             *\n             * // Retrieve data\n             * const prefs = store.get(\"user_preferences\");\n             *\n             * // Check if key exists\n             * if (store.has(\"user_preferences\")) {\n             *   // Key exists\n             * }\n             */\n            exports_1(\"store\", store = {\n                set: (key, value, persist = false) => {\n                    let val = encodeURIComponent(JSON.stringify({ value: value }));\n                    persist ? setCommand(\"persistant\", key, val) : setExtraInfo(key, val);\n                },\n                get: (key) => {\n                    let val = undefined;\n                    try {\n                        val = JSON.parse(decodeURIComponent(_store[key])).value;\n                    }\n                    catch {\n                        log(`key: ${key} not found in the store.`);\n                    }\n                    return val;\n                },\n                has: (key) => (key in _store)\n            });\n            // MARK: LOGS\n            _logs = [];\n        }\n    };\n});\nSystem.register(\"shared\", [\"core\"], function (exports_2, context_2) {\n    \"use strict\";\n    var core;\n    var __moduleName = context_2 && context_2.id;\n    function extractJsonString(text) {\n        // Match the first {...} or [...] block (non-greedy)\n        const match = text.match(/({[\\s\\S]*}|\\[[\\s\\S]*\\])/);\n        return match ? JSON.parse(match[0]) : null;\n    }\n    exports_2(\"extractJsonString\", extractJsonString);\n    /**\n     * Given an array of chapter entries, returns only the preferred group for each chap.\n     * @param {Array} chapters - Array of chapter objects with 'chap' and 'group_name'.\n     * @param {Array} preferredGroups - Array of group names in order of preference.\n     * @returns {Array} Filtered array with only preferred group per chap.\n     */\n    function filterChaptersByPreferredGroup(chapters, preferredGroups) {\n        // Group chapters by chap number\n        const chapMap = new Map();\n        for (const entry of chapters) {\n            const chapNum = entry.chap;\n            if (!chapMap.has(chapNum))\n                chapMap.set(chapNum, []);\n            chapMap.get(chapNum).push(entry);\n        }\n        // For each chap, pick the preferred group\n        const result = [];\n        for (const [chapNum, groupEntries] of chapMap.entries()) {\n            // Sort by preferredGroups order\n            groupEntries.sort((a, b) => {\n                const aIdx = preferredGroups.indexOf(a.group_name);\n                const bIdx = preferredGroups.indexOf(b.group_name);\n                return (aIdx === -1 ? Infinity : aIdx) - (bIdx === -1 ? Infinity : bIdx);\n            });\n            result.push(groupEntries[0]); // Pick the top-ranked group\n        }\n        return result;\n    }\n    exports_2(\"filterChaptersByPreferredGroup\", filterChaptersByPreferredGroup);\n    function ImageService(data) {\n        return core.request('https://meo.comick.pictures/' + data);\n    }\n    exports_2(\"ImageService\", ImageService);\n    function InfoService(data) {\n        return core.request(`https://comick.io/comic/${data}?lang=en`);\n    }\n    exports_2(\"InfoService\", InfoService);\n    return {\n        setters: [\n            function (core_1) {\n                core = core_1;\n            }\n        ],\n        execute: function () {\n        }\n    };\n});\nSystem.register(\"mainPage\", [\"core\", \"shared\"], function (exports_3, context_3) {\n    \"use strict\";\n    var core, shared_1, res1, Trending, RisingStars, AdaptedManga, Completed, Recent;\n    var __moduleName = context_3 && context_3.id;\n    return {\n        setters: [\n            function (core_2) {\n                core = core_2;\n            },\n            function (shared_1_1) {\n                shared_1 = shared_1_1;\n            }\n        ],\n        execute: async function () {\n            res1 = await core.fetch(\"https://comick.io/\", {}, (w) => {\n                return JSON.parse(w.document.querySelector('[id=__NEXT_DATA__]').textContent)['props']['pageProps']['data'];\n            });\n            Trending = Array.from(res1['trending'][7]).map((item, index) => {\n                let title = item['title'];\n                let image = shared_1.ImageService(item['md_covers'][0]['b2key']);\n                let link = shared_1.InfoService(item['slug']);\n                return core.view({\n                    link: link,\n                    image: image,\n                    title: title,\n                    field1: `${index + 1}`\n                });\n            });\n            RisingStars = Array.from(res1['topFollowNewComics'][7]).map((item) => {\n                let title = item['title'];\n                let image = shared_1.ImageService(item['md_covers'][0]['b2key']);\n                let link = shared_1.InfoService(item['slug']);\n                return core.view({\n                    link: link,\n                    image: image,\n                    title: title\n                });\n            });\n            AdaptedManga = Array.from(res1['comicsByCurrentSeason']['data']).map((item) => {\n                let title = item['title'];\n                let image = shared_1.ImageService(item['md_covers'][0]['b2key']);\n                let link = shared_1.InfoService(item['slug']);\n                return core.view({\n                    link: link,\n                    image: image,\n                    title: title\n                });\n            });\n            Completed = Array.from(res1['completions']).map((item) => {\n                let title = item['title'];\n                let image = shared_1.ImageService(item['md_covers'][0]['b2key']);\n                let link = shared_1.InfoService(item['slug']);\n                return core.view({\n                    link: link,\n                    image: image,\n                    title: title\n                });\n            });\n            Recent = Array.from(res1['news']).map((item) => {\n                let title = item['title'];\n                let image = shared_1.ImageService(item['md_covers'][0]['b2key']);\n                let link = shared_1.InfoService(item['slug']);\n                return core.view({\n                    link: link,\n                    image: image,\n                    title: title\n                });\n            });\n            core.main([\n                core.viewsHolder({\n                    orientation: \"horizontal\",\n                    design: \"wide3\",\n                    distribution: \"longTripletsDouble\",\n                    title: \"Trending\",\n                    views: Trending\n                }), core.viewsHolder({\n                    orientation: \"horizontal\",\n                    design: \"wide10\",\n                    distribution: \"longTripletsDouble\",\n                    title: \"Rising Stars\",\n                    views: RisingStars\n                }), core.viewsHolder({\n                    orientation: \"horizontal\",\n                    design: \"wide3\",\n                    distribution: \"wideFull\",\n                    title: \"Adapted To Mange\",\n                    views: AdaptedManga\n                }), core.viewsHolder({\n                    orientation: \"horizontal\",\n                    design: \"wide3\",\n                    distribution: \"wideFull\",\n                    title: \"Adapted To Mange\",\n                    views: Completed\n                }), core.viewsHolder({\n                    orientation: \"horizontal\",\n                    design: \"wide3\",\n                    distribution: \"wideFull\",\n                    title: \"Adapted To Mange\",\n                    views: Recent\n                })\n            ]);\n        }\n    };\n});\n\n            System.import(\"mainPage\");\n            "},"output":[{"cellDesing":"normal1","orientation":"vertical","defaultLayout":"wide","paging":"","section":{"sectionName":"","separator":false},"layout":{"insets":{"top":0,"bottom":0,"left":0,"right":0},"visibleCellsWidthS":2,"visibleCellsWidthM":2,"visibleCellsWidthL":2,"visibleCellsHeight":2,"heightForVisibleCells":400,"cellSize":{"width":300,"height":300},"ratio":{"inRelation":"width","number1":1,"number2":2},"constant":{"width":1,"height":2},"horizontalSpacing":0,"verticalSpacing":0},"data":[{"image":{"url":"","method":"GET","headers":[{"key":"","value":""}],"httpBody":null},"title":"","description":"","field1":"","field2":"","field3":"","field4":"","openInWebView":false,"isChapter":false,"link":{"url":"","method":"","headers":[{"key":"","value":""}],"httpBody":null}}]}],"fileType":"mainPage","fileSection":"Module","fileID":2253367988,"fileName":"mainPage.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":false},"code":{"route":["javascriptConfig","javaScript"],"name":"Code Editor","data":"import * as core from \"./core\"\nimport { ImageService, InfoService } from \"./shared\"\n\nlet res1 = await core.fetch(\"https://comick.io/\", {}, (w) => {\n    return JSON.parse(w.document.querySelector('[id=__NEXT_DATA__]')!.textContent!)['props']['pageProps']['data'];\n});\n\nlet Trending = Array.from(res1['trending'][7]).map((item: any, index: any) => {\n    let title = item['title'];\n    let image = ImageService(item['md_covers'][0]['b2key']);\n    let link = InfoService(item['slug']); \n\n    return core.view({\n        link: link,\n        image: image,\n        title : title,\n        field1: `${index + 1}`\n    })\n});\n\nlet RisingStars = Array.from(res1['topFollowNewComics'][7]).map((item: any) => {\n    let title = item['title'];\n    let image = ImageService(item['md_covers'][0]['b2key']);\n    let link = InfoService(item['slug']);\n\n    return core.view({\n        link: link,\n        image: image,\n        title : title\n    })\n});\n\nlet AdaptedManga = Array.from(res1['comicsByCurrentSeason']['data']).map((item: any) => {\n    let title = item['title'];\n    let image = ImageService(item['md_covers'][0]['b2key']);\n    let link = InfoService(item['slug']); \n\n    return core.view({\n        link: link,\n        image: image,\n        title : title\n    })\n});\n\nlet Completed = Array.from(res1['completions']).map((item: any) => {\n    let title = item['title'];\n    let image = ImageService(item['md_covers'][0]['b2key']);\n    let link = InfoService(item['slug']);\n\n    return core.view({\n        link: link,\n        image: image,\n        title : title\n    })\n});\n\nlet Recent = Array.from(res1['news']).map((item: any) => {\n    let title = item['title'];\n    let image = ImageService(item['md_covers'][0]['b2key']);\n    let link = InfoService(item['slug']);\n\n    return core.view({\n        link: link,\n        image: image,\n        title : title\n    })\n});\n\ncore.main([\n    core.viewsHolder({\n        orientation: \"horizontal\",\n        design: \"wide3\",\n        distribution: \"longTripletsDouble\",\n        title : \"Trending\",\n        views : Trending\n    }), core.viewsHolder({\n        orientation: \"horizontal\",\n        design: \"wide10\",\n        distribution: \"longTripletsDouble\",\n        title : \"Rising Stars\",\n        views : RisingStars\n    }), core.viewsHolder({\n        orientation: \"horizontal\",\n        design: \"wide3\",\n        distribution: \"wideFull\",\n        title: \"Adapted To Mange\",\n        views: AdaptedManga\n    }), core.viewsHolder({\n        orientation: \"horizontal\",\n        design: \"wide3\",\n        distribution: \"wideFull\",\n        title: \"Adapted To Mange\",\n        views: Completed\n    }), core.viewsHolder({\n        orientation: \"horizontal\",\n        design: \"wide3\",\n        distribution: \"wideFull\",\n        title: \"Adapted To Mange\",\n        views: Recent\n    })\n])","type":"typescript","compiled":true,"status":true,"shared":false,"line":42}},"fileIndexPath":[3,0]}],"search":[{"request":{"url":"https://google.com/?ketsu_search=<searched>&ketsu_page=<page>","method":"GET","headers":[{"key":"","value":""}]},"separator":"","extra":{"commands":[{"commandName":"","params":[{"key":"","value":""}]}],"extraInfo":[{"key":"","value":""}]},"javascriptConfig":{"removeJavascript":true,"loadInWebView":false,"javaScript":"\n            var System = (function() {\n  var modules = {};\n  \n  function register(name, deps, declare) {\n      modules[name] = { deps: deps, declare: declare };\n  }\n  \n  function getModule(name) {\n      var module = modules[name];\n      if (!module) throw new Error('Module ' + name + ' not found');\n      if (module.exports) return module.exports;\n      \n      var exports = {};\n      var context = { id: name };\n      \n      // Create a function to export values\n      function exportFn(key, value) {\n          if (arguments.length === 1) {\n              Object.assign(exports, key);\n          } else {\n              exports[key] = value;\n          }\n      }\n      \n      var setters = [];\n      var depExports = [];\n      \n      // Load dependencies first\n      for (var i = 0; i < module.deps.length; i++) {\n          if (module.deps[i] !== 'exports') {\n              depExports.push(getModule(module.deps[i]));\n          }\n      }\n      \n      // Call the module declaration\n      var declared = module.declare(exportFn, context);\n      \n      // Call setters with loaded dependencies\n      if (declared.setters) {\n          var depIndex = 0;\n          for (var i = 0; i < declared.setters.length; i++) {\n              if (declared.setters[i]) {\n                  declared.setters[i](depExports[depIndex++]);\n              }\n          }\n      }\n      \n      // Execute the module\n      if (declared.execute) {\n          declared.execute();\n      }\n      \n      module.exports = exports;\n      return exports;\n  }\n  \n  return {\n      register: register,\n      import: function(name) { \n          getModule(name);\n      }\n  };\n})();\n\n            System.register(\"core\", [], function (exports_1, context_1) {\n    \"use strict\";\n    var emptyKeyVal, defaultImage, defaultRequest, _metadata, _store, store, _logs;\n    var __moduleName = context_1 && context_1.id;\n    /**\n     * Makes an HTTP request to a website, you can also run javascript directly on the website.\n     * @param url - The URL to fetch\n     * @param options - Fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Simple fetch\n     * const html = await fetch(\"https://example.com\");\n     *\n     * @example\n     * // Fetch and execute code in site context\n     * const result = await fetch(\"https://example.com\", {}, (window) => {\n     *   return window.document.title;\n     * });\n     */\n    async function fetch(url, options = {}, ...run) {\n        let meta = metadata();\n        let metaUrl = meta.request.url;\n        if (url === metaUrl) {\n            let res = run.length > 0 ? await run[0]?.(window) : window.document.documentElement.outerHTML;\n            store.set(url, res);\n            return run.length > 0 ? res : window.document.documentElement;\n        }\n        let cached = store.get(url);\n        if (cached === undefined) {\n            meta.request = request(url, options);\n            meta.javascriptConfig.loadInWebView = options.loadInSite ?? false;\n            meta.javascriptConfig.removeJavascript = options.removeScripts ?? false;\n            return finish();\n        }\n        return (typeof cached === \"string\" && cached.trim().startsWith('<')) ?\n            (new DOMParser()).parseFromString(cached, \"text/html\").documentElement :\n            cached;\n    }\n    exports_1(\"fetch\", fetch);\n    /**\n     * Same as fetch but used on parts of the module where the Request is dynamic, must be used at first of the Info, Chapters and Resolvers scripts.\n     * @param options - Dynamic fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Dynamic fetch with test URL\n     * const result = await dynamicFetch({ testURL: \"https://api.example.com\" });\n     */\n    async function dynamicFetch(_options = {}, ...run) {\n        let meta = metadata();\n        let currentURL = meta.request.url;\n        let url = store.get(\"ketsu_dynamic\");\n        let options = _options;\n        if (options.testURL) {\n            url = options.testURL;\n        }\n        if (!url) {\n            if (!currentURL.includes(\"ketsu_dynamic=\")) {\n                throw new Error(\"No dynamic URL available and no testURL provided.\");\n            }\n            const encoded = currentURL.split(\"ketsu_dynamic=\")[1];\n            const originalRequest = JSON.parse(decodeURIComponent(encoded));\n            url = originalRequest.url;\n            // Merge headers/body/method only if not already defined\n            options.method ?? (options.method = originalRequest.method);\n            options.body ?? (options.body = originalRequest.httpBody);\n            const originalHeaders = Object.fromEntries(originalRequest.headers.map(kv => [kv.key, kv.value]));\n            options.headers = {\n                ...originalHeaders,\n                ...options.headers\n            };\n            // Save resolved URL to prevent repeating decoding later\n            store.set(\"ketsu_dynamic\", url);\n        }\n        return fetch(url, options, ...run);\n    }\n    exports_1(\"dynamicFetch\", dynamicFetch);\n    function toast(text) {\n        action(\"KETSU_MSG\", text);\n    }\n    exports_1(\"toast\", toast);\n    // MARK: REQUEST\n    /**\n     * Creates a request object for KETSU\n     * @param url - The target URL\n     * @param options - Request configuration options\n     * @returns Request object formatted for the Ketsu framework\n     *\n     * @example\n     * const req = request(\"https://api.example.com\", {\n     *   method: \"POST\",\n     *   headers: { \"Content-Type\": \"application/json\" },\n     *   body: JSON.stringify({ data: \"example\" })\n     * });\n     */\n    function request(url, options = {}) {\n        return {\n            url: url,\n            method: options.method || \"GET\",\n            headers: options.headers ? Object.keys(options.headers).map((k) => ({ key: k, value: options.headers?.[k] || \"\" })) : emptyKeyVal,\n            httpBody: options.body\n        };\n    }\n    exports_1(\"request\", request);\n    function dynamicRequest(request) {\n        return {\n            url: `https://google.com/?ketsu_dynamic=${encodeURIComponent(JSON.stringify(request))}`,\n            method: \"GET\",\n            headers: emptyKeyVal,\n            httpBody: undefined\n        };\n    }\n    function viewsHolder(h) {\n        return {\n            cellDesing: h.design || \"wide5\",\n            defaultLayout: h.distribution || \"wideStrechedFullList\",\n            orientation: h.orientation || \"vertical\",\n            section: {\n                sectionName: h.title || \"\",\n                separator: true\n            },\n            paging: \"leading\",\n            data: h.views || [],\n            layout: undefined,\n        };\n    }\n    exports_1(\"viewsHolder\", viewsHolder);\n    /**\n     * Creates a content view with default values\n     * @param v - Partial view configuration\n     * @returns Complete View object with defaults applied\n     *\n     * @example\n     * const movieView = view({\n     *   title: \"The Matrix\",\n     *   description: \"A computer hacker learns about reality\",\n     *   image: request(\"https://example.com/matrix.jpg\"),\n     *   link: request(\"https://example.com/matrix\")\n     * });\n     */\n    function view(v) {\n        return {\n            link: dynamicRequest(v.link || defaultRequest),\n            image: v.image || defaultImage,\n            title: v.title || \"\",\n            description: v.description || \"\",\n            field1: v.field1 || \"\",\n            field2: v.field2 || \"\",\n            field3: v.field3 || \"\",\n            field4: v.field4 || \"\",\n            isChapter: false,\n            openInWebView: false\n        };\n    }\n    exports_1(\"view\", view);\n    // MARK: MAINPAGE\n    /**\n     * Sets up the main page layout with the provided view holders\n     * @param layout - Array of ViewsHolder objects to display on the main page\n     *\n     * @example\n     * main([\n     *   viewsHolder({ title: \"Featured\", views: featuredViews }),\n     *   viewsHolder({ title: \"Popular\", views: popularViews })\n     * ]);\n     */\n    function main(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"main\", main);\n    // MARK: SEARCHPAGE\n    /**\n     * Sets up the search results page layout\n     * @param layout - Array of ViewsHolder objects to display search results\n     *\n     * @example\n     * search([\n     *   viewsHolder({ title: \"Search Results\", views: searchResults })\n     * ]);\n     */\n    function search(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"search\", search);\n    /**\n     * Retrieves current search metadata (query and page), must be used at the start of the search script.\n     * @param test - Optional test metadata to override URL parsing\n     * @returns Search metadata object\n     *\n     * @example\n     * const { searched, page } = searchMetadata();\n     * console.log(`Searching for: ${searched}, Page: ${page}`);\n     */\n    function searchMetadata(test) {\n        let meta = metadata();\n        let searchMeta = store.get(\"ketsu_search\");\n        if (!searchMeta && meta.request.url.includes(\"?ketsu_search=\")) {\n            let url = new URL(meta.request.url).searchParams;\n            let searched = url.get(\"ketsu_search\") || \"\";\n            let page = parseInt(url.get(\"page\") || \"0\", 10);\n            searchMeta = {\n                searched: test?.searched ? test.searched : searched,\n                page: test?.page ? test.page : page\n            };\n            store.set(\"ketsu_search\", searchMeta);\n        }\n        return searchMeta || { searched: \"\", page: 0 };\n    }\n    exports_1(\"searchMetadata\", searchMetadata);\n    /**\n     * Creates a chapter request object\n     * @param url - Chapter URL\n     * @param options - Chapter configuration options\n     * @returns ChapterRequest object\n     *\n     * @example\n     * const chapter = chapterRequest(\"https://example.com/chapter1\", {\n     *   name: \"Chapter 1: The Beginning\",\n     *   openInWebView: false\n     * });\n     */\n    function chapterRequest(url, options = {}) {\n        return {\n            chapName: options.name,\n            link: dynamicRequest(request(url, options)),\n            openInWebView: options.openInWebView ?? false\n        };\n    }\n    exports_1(\"chapterRequest\", chapterRequest);\n    /**\n     * Sets up an information/detail page\n     * @param data - Partial info page configuration\n     *\n     * @example\n     * info({\n     *   title: \" Some title\",\n     *   description: \"A high school chemistry teacher turned meth cook\",\n     *   genres: [\"Drama\", \"Crime\", \"Thriller\"],\n     *   chapters: [chapter1, chapter2, chapter3]\n     * });\n     */\n    function info(data) {\n        let l = {\n            image: data.image || defaultImage,\n            link: data.link || metadata().request,\n            title: data.title || \"\",\n            description: data.description || \"\",\n            genres: data.genres || [],\n            field1: data.field1 || \"\",\n            field2: data.field2 || \"\",\n            field3: data.field3 || \"\",\n            field4: data.field4 || \"\",\n            chapters: data.chapters || []\n        };\n        metadata().output = l;\n        finish();\n    }\n    exports_1(\"info\", info);\n    /**\n     * Sets up chapter content (videos, images, or text)\n     * @param data - Chapter content data (images, videos, or text string)\n     *\n     * @example\n     * // For image-based content (manga)\n     * chapters([\n     *   request(\"https://example.com/page1.jpg\"),\n     *   request(\"https://example.com/page2.jpg\")\n     * ]);\n     *\n     * @example\n     * // For video content\n     * chapters([\n     *   videoRequest(\"https://example.com/video.mp4\"),\n     *   resolverRequest(\"https://example.com/embed\")\n     * ]);\n     *\n     * @example\n     * // For text content\n     * chapters(\"This is the chapter text content...\");\n     */\n    function chapters(data) {\n        let output = {\n            videos: undefined,\n            text: undefined,\n            images: undefined\n        };\n        if (!Array.isArray(data)) {\n            if (typeof data !== \"string\") {\n                throw new Error(\"Chapters type is wrong\");\n            }\n            output.text = { text: data };\n        }\n        if (Array.isArray(data) && data.some((k) => (\"url\" in k))) {\n            output.images = data;\n        }\n        else if (Array.isArray(data)) {\n            output.videos = {\n                needsResolver: [],\n                rawVideo: []\n            };\n            data.forEach((v) => \"video\" in v ? output.videos.rawVideo.push(v) : output.videos.needsResolver.push(v));\n        }\n        metadata().output = output;\n        finish();\n    }\n    exports_1(\"chapters\", chapters);\n    // MARK: RESOLVE\n    /**\n     * Returns the video resolved from the embeded website.\n     * @param video - VideoRequest object to resolve\n     *\n     * @example\n     * const resolvedVideo = videoRequest(\"https://cdn.example.com/video.mp4\");\n     * resolver(resolvedVideo);\n     */\n    function resolver(video) {\n        metadata().output = video;\n        finish();\n    }\n    exports_1(\"resolver\", resolver);\n    /**\n     * Creates a resolver request for extracting video URLs from embed pages\n     * @param url - URL to the video resolver/embed page\n     * @param options - Resolver configuration options\n     * @returns ResolverRequest object\n     *\n     * @example\n     * const resolver = resolverRequest(\"https://streamwebsite.com/video123\", {\n     *   resolverID: \"STREAMWEBSITE\" //\n     * });\n     */\n    function resolverRequest(url, options) {\n        return {\n            link: dynamicRequest(request(url, options)),\n            resolverIdentifier: options?.resolverID || \"\"\n        };\n    }\n    exports_1(\"resolverRequest\", resolverRequest);\n    /**\n     * Creates a subtitle request\n     * @param url - URL to subtitle file\n     * @param options - Subtitle configuration options\n     * @returns SubsRequest object\n     *\n     * @example\n     * const subtitles = subsRequest(\"https://example.com/subs.vtt\", {\n     *   language: \"English\"\n     * });\n     */\n    function subsRequest(url, options) {\n        return {\n            link: request(url, options),\n            language: options?.language || \"unknown\"\n        };\n    }\n    exports_1(\"subsRequest\", subsRequest);\n    /**\n     * Creates a video request with quality and subtitle options\n     * @param url - Direct video URL\n     * @param options - Video configuration options\n     * @returns VideoRequest object\n     *\n     * @example\n     * const video = videoRequest(\"https://example.com/video.mp4\", {\n     *   quality: \"1080p\",\n     *   subs: [\n     *     subsRequest(\"https://example.com/en.vtt\", { language: \"English\" }),\n     *     subsRequest(\"https://example.com/es.vtt\", { language: \"Spanish\" })\n     *   ]\n     * });\n     */\n    function videoRequest(url, options) {\n        return {\n            video: [{\n                    videoLink: request(url, options),\n                    videoQuality: options?.quality || \"auto\"\n                }],\n            subs: options?.subs\n        };\n    }\n    exports_1(\"videoRequest\", videoRequest);\n    function metadata() {\n        if (!_metadata) {\n            const savedData = document.getElementById('ketsu-final-data');\n            _metadata = JSON.parse(savedData?.textContent || \"\");\n        }\n        return _metadata;\n    }\n    // MARK: Finish\n    function finish() {\n        const savedData = document.getElementById('ketsu-final-data');\n        _metadata ? (savedData.textContent = JSON.stringify(_metadata)) : (undefined);\n        _logs.forEach((l) => action(\"KETSU_LOG\", l));\n        action(\"EXECUTE_KETSU_ASYNC\");\n        throw new Error();\n    }\n    function setExtraInfo(key, value) {\n        let meta = metadata();\n        let kv = meta.extra.extraInfo.find((k) => k.key === key);\n        if (!kv) {\n            kv = {\n                key: \"\",\n                value: \"\"\n            };\n            meta.extra.extraInfo.push(kv);\n        }\n        kv.key = key;\n        kv.value = value;\n    }\n    function setCommand(name, key, value) {\n        let meta = metadata();\n        let command = meta.extra.commands.find((c) => c.commandName == name);\n        if (!command) {\n            command = {\n                commandName: name,\n                params: []\n            };\n            meta.extra.commands.push(command);\n        }\n        command.params.push({ key, value });\n    }\n    function action(name, val = \"\") {\n        if (\"webkit\" in window) {\n            window.webkit.messageHandlers[name].postMessage(val);\n        }\n        else if (name === \"KETSU_LOG\") {\n            console.log(val);\n        }\n    }\n    /**\n     * Logs messages for debugging purposes\n     * @param args - Values to log\n     *\n     * @example\n     * log(\"Debug message\", { data: \"example\" });\n     * log(\"User action:\", userAction, \"Result:\", result);\n     */\n    function log(...args) {\n        const stringifiedArgs = args.map(arg => stringify(arg)).join('\\n\\n');\n        _logs.push(stringifiedArgs);\n    }\n    exports_1(\"log\", log);\n    function stringify(value) {\n        // Primitives\n        if (value === null)\n            return 'null';\n        if (value === undefined)\n            return 'undefined';\n        if (typeof value === 'string')\n            return value;\n        if (typeof value === 'number' || typeof value === 'boolean')\n            return String(value);\n        // Functions\n        if (typeof value === 'function') {\n            return `[Function: ${value.name || 'anonymous'}]`;\n        }\n        // Errors\n        if (value instanceof Error) {\n            return `${value.name}: ${value.message}`;\n        }\n        // Everything else - just stringify with pretty print\n        try {\n            return JSON.stringify(value, (key, val) => {\n                if (typeof val === 'function') {\n                    return `[Function: ${val.name || 'anonymous'}]`;\n                }\n                if (val instanceof Error) {\n                    return `${val.name}: ${val.message}`;\n                }\n                return val;\n            }, 2);\n        }\n        catch (e) {\n            return `[${value.constructor?.name || 'Object'}]`;\n        }\n    }\n    return {\n        setters: [],\n        execute: function () {\n            // MARK:GLOBAL\n            window.KETSU_ASYNC = true;\n            emptyKeyVal = [{ key: \"\", value: \"\" }];\n            defaultImage = request(\"https://www.shutterstock.com/image-vector/default-ui-image-placeholder-wireframes-600nw-1037719192.jpg\");\n            defaultRequest = request(\"https://www.google.com/\");\n            _metadata = undefined;\n            _store = {\n                ...[...metadata().extra.extraInfo, ...metadata().global.variables].reduce((acc, val) => {\n                    acc[val.key] = val.value;\n                    return acc;\n                }, {})\n            };\n            /**\n             * Global storage instance for persisting data\n             *\n             * @example\n             * // Store data\n             * store.set(\"user_preferences\", { theme: \"dark\" });\n             *\n             * // Retrieve data\n             * const prefs = store.get(\"user_preferences\");\n             *\n             * // Check if key exists\n             * if (store.has(\"user_preferences\")) {\n             *   // Key exists\n             * }\n             */\n            exports_1(\"store\", store = {\n                set: (key, value, persist = false) => {\n                    let val = encodeURIComponent(JSON.stringify({ value: value }));\n                    persist ? setCommand(\"persistant\", key, val) : setExtraInfo(key, val);\n                },\n                get: (key) => {\n                    let val = undefined;\n                    try {\n                        val = JSON.parse(decodeURIComponent(_store[key])).value;\n                    }\n                    catch {\n                        log(`key: ${key} not found in the store.`);\n                    }\n                    return val;\n                },\n                has: (key) => (key in _store)\n            });\n            // MARK: LOGS\n            _logs = [];\n        }\n    };\n});\nSystem.register(\"shared\", [\"core\"], function (exports_2, context_2) {\n    \"use strict\";\n    var core;\n    var __moduleName = context_2 && context_2.id;\n    function extractJsonString(text) {\n        // Match the first {...} or [...] block (non-greedy)\n        const match = text.match(/({[\\s\\S]*}|\\[[\\s\\S]*\\])/);\n        return match ? JSON.parse(match[0]) : null;\n    }\n    exports_2(\"extractJsonString\", extractJsonString);\n    /**\n     * Given an array of chapter entries, returns only the preferred group for each chap.\n     * @param {Array} chapters - Array of chapter objects with 'chap' and 'group_name'.\n     * @param {Array} preferredGroups - Array of group names in order of preference.\n     * @returns {Array} Filtered array with only preferred group per chap.\n     */\n    function filterChaptersByPreferredGroup(chapters, preferredGroups) {\n        // Group chapters by chap number\n        const chapMap = new Map();\n        for (const entry of chapters) {\n            const chapNum = entry.chap;\n            if (!chapMap.has(chapNum))\n                chapMap.set(chapNum, []);\n            chapMap.get(chapNum).push(entry);\n        }\n        // For each chap, pick the preferred group\n        const result = [];\n        for (const [chapNum, groupEntries] of chapMap.entries()) {\n            // Sort by preferredGroups order\n            groupEntries.sort((a, b) => {\n                const aIdx = preferredGroups.indexOf(a.group_name);\n                const bIdx = preferredGroups.indexOf(b.group_name);\n                return (aIdx === -1 ? Infinity : aIdx) - (bIdx === -1 ? Infinity : bIdx);\n            });\n            result.push(groupEntries[0]); // Pick the top-ranked group\n        }\n        return result;\n    }\n    exports_2(\"filterChaptersByPreferredGroup\", filterChaptersByPreferredGroup);\n    function ImageService(data) {\n        return core.request('https://meo.comick.pictures/' + data);\n    }\n    exports_2(\"ImageService\", ImageService);\n    function InfoService(data) {\n        return core.request(`https://comick.io/comic/${data}?lang=en`);\n    }\n    exports_2(\"InfoService\", InfoService);\n    return {\n        setters: [\n            function (core_1) {\n                core = core_1;\n            }\n        ],\n        execute: function () {\n        }\n    };\n});\nSystem.register(\"search\", [\"core\"], function (exports_3, context_3) {\n    \"use strict\";\n    var core;\n    var __moduleName = context_3 && context_3.id;\n    return {\n        setters: [\n            function (core_2) {\n                core = core_2;\n            }\n        ],\n        execute: function () {\n            // TODO CREATE SEARCH METADATA FUNCTION\n            core.log(core.searchMetadata({ searched: \"reincarnated\", page: 1 }));\n            core.search([\n                core.viewsHolder({\n                    views: [\n                        core.view({\n                            title: \"hello\"\n                        }),\n                        core.view({\n                            title: \"hello\"\n                        }),\n                        core.view({\n                            title: \"hello\"\n                        })\n                    ]\n                })\n            ]);\n        }\n    };\n});\n\n            System.import(\"search\");\n            "},"output":[{"cellDesing":"normal1","orientation":"vertical","defaultLayout":"wide","paging":"","section":{"sectionName":"","separator":false},"layout":{"insets":{"top":0,"bottom":0,"left":0,"right":0},"visibleCellsWidthS":2,"visibleCellsWidthM":2,"visibleCellsWidthL":2,"visibleCellsHeight":2,"heightForVisibleCells":400,"cellSize":{"width":300,"height":300},"ratio":{"inRelation":"width","number1":1,"number2":2},"constant":{"width":1,"height":2},"horizontalSpacing":0,"verticalSpacing":0},"data":[{"image":{"url":"","method":"GET","headers":[{"key":"","value":""}],"httpBody":null},"title":"","description":"","field1":"","field2":"","field3":"","field4":"","openInWebView":false,"isChapter":false,"link":{"url":"empty","method":"GET","headers":[{"key":"key","value":"value"}],"httpBody":null}}]}],"fileType":"search","fileSection":"Module","fileID":1463255157,"fileName":"search.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":false},"code":{"route":["javascriptConfig","javaScript"],"name":"Code Editor","data":"import * as core from \"./core\"\nimport * as shared from \"./shared\"\n\n// TODO CREATE SEARCH METADATA FUNCTION\n\ncore.log(core.searchMetadata({searched: \"reincarnated\", page: 1}))\n\ncore.search([\n    core.viewsHolder({\n        views : [\n            core.view({\n                title : \"hello\"\n            }),\n             core.view({\n                title : \"hello\"\n            }),\n             core.view({\n                title : \"hello\"\n            })\n        ]\n    })\n])","type":"typescript","compiled":true,"status":true,"shared":false,"line":22}},"fileIndexPath":[4,0]}],"info":[{"request":{"url":"https://google.com","method":"GET","headers":[{"key":"","value":""}]},"extra":{"commands":[{"commandName":"","params":[{"key":"","value":""}]}],"extraInfo":[{"key":"","value":""}]},"javascriptConfig":{"removeJavascript":true,"loadInWebView":false,"javaScript":"\n            var System = (function() {\n  var modules = {};\n  \n  function register(name, deps, declare) {\n      modules[name] = { deps: deps, declare: declare };\n  }\n  \n  function getModule(name) {\n      var module = modules[name];\n      if (!module) throw new Error('Module ' + name + ' not found');\n      if (module.exports) return module.exports;\n      \n      var exports = {};\n      var context = { id: name };\n      \n      // Create a function to export values\n      function exportFn(key, value) {\n          if (arguments.length === 1) {\n              Object.assign(exports, key);\n          } else {\n              exports[key] = value;\n          }\n      }\n      \n      var setters = [];\n      var depExports = [];\n      \n      // Load dependencies first\n      for (var i = 0; i < module.deps.length; i++) {\n          if (module.deps[i] !== 'exports') {\n              depExports.push(getModule(module.deps[i]));\n          }\n      }\n      \n      // Call the module declaration\n      var declared = module.declare(exportFn, context);\n      \n      // Call setters with loaded dependencies\n      if (declared.setters) {\n          var depIndex = 0;\n          for (var i = 0; i < declared.setters.length; i++) {\n              if (declared.setters[i]) {\n                  declared.setters[i](depExports[depIndex++]);\n              }\n          }\n      }\n      \n      // Execute the module\n      if (declared.execute) {\n          declared.execute();\n      }\n      \n      module.exports = exports;\n      return exports;\n  }\n  \n  return {\n      register: register,\n      import: function(name) { \n          getModule(name);\n      }\n  };\n})();\n\n            System.register(\"core\", [], function (exports_1, context_1) {\n    \"use strict\";\n    var emptyKeyVal, defaultImage, defaultRequest, _metadata, _store, store, _logs;\n    var __moduleName = context_1 && context_1.id;\n    /**\n     * Makes an HTTP request to a website, you can also run javascript directly on the website.\n     * @param url - The URL to fetch\n     * @param options - Fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Simple fetch\n     * const html = await fetch(\"https://example.com\");\n     *\n     * @example\n     * // Fetch and execute code in site context\n     * const result = await fetch(\"https://example.com\", {}, (window) => {\n     *   return window.document.title;\n     * });\n     */\n    async function fetch(url, options = {}, ...run) {\n        let meta = metadata();\n        let metaUrl = meta.request.url;\n        if (url === metaUrl) {\n            let res = run.length > 0 ? await run[0]?.(window) : window.document.documentElement.outerHTML;\n            store.set(url, res);\n            return run.length > 0 ? res : window.document.documentElement;\n        }\n        let cached = store.get(url);\n        if (cached === undefined) {\n            meta.request = request(url, options);\n            meta.javascriptConfig.loadInWebView = options.loadInSite ?? false;\n            meta.javascriptConfig.removeJavascript = options.removeScripts ?? false;\n            return finish();\n        }\n        return (typeof cached === \"string\" && cached.trim().startsWith('<')) ?\n            (new DOMParser()).parseFromString(cached, \"text/html\").documentElement :\n            cached;\n    }\n    exports_1(\"fetch\", fetch);\n    /**\n     * Same as fetch but used on parts of the module where the Request is dynamic, must be used at first of the Info, Chapters and Resolvers scripts.\n     * @param options - Dynamic fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Dynamic fetch with test URL\n     * const result = await dynamicFetch({ testURL: \"https://api.example.com\" });\n     */\n    async function dynamicFetch(_options = {}, ...run) {\n        let meta = metadata();\n        let currentURL = meta.request.url;\n        let url = store.get(\"ketsu_dynamic\");\n        let options = _options;\n        if (options.testURL) {\n            url = options.testURL;\n        }\n        if (!url) {\n            if (!currentURL.includes(\"ketsu_dynamic=\")) {\n                throw new Error(\"No dynamic URL available and no testURL provided.\");\n            }\n            const encoded = currentURL.split(\"ketsu_dynamic=\")[1];\n            const originalRequest = JSON.parse(decodeURIComponent(encoded));\n            url = originalRequest.url;\n            // Merge headers/body/method only if not already defined\n            options.method ?? (options.method = originalRequest.method);\n            options.body ?? (options.body = originalRequest.httpBody);\n            const originalHeaders = Object.fromEntries(originalRequest.headers.map(kv => [kv.key, kv.value]));\n            options.headers = {\n                ...originalHeaders,\n                ...options.headers\n            };\n            // Save resolved URL to prevent repeating decoding later\n            store.set(\"ketsu_dynamic\", url);\n        }\n        return fetch(url, options, ...run);\n    }\n    exports_1(\"dynamicFetch\", dynamicFetch);\n    function toast(text) {\n        action(\"KETSU_MSG\", text);\n    }\n    exports_1(\"toast\", toast);\n    // MARK: REQUEST\n    /**\n     * Creates a request object for KETSU\n     * @param url - The target URL\n     * @param options - Request configuration options\n     * @returns Request object formatted for the Ketsu framework\n     *\n     * @example\n     * const req = request(\"https://api.example.com\", {\n     *   method: \"POST\",\n     *   headers: { \"Content-Type\": \"application/json\" },\n     *   body: JSON.stringify({ data: \"example\" })\n     * });\n     */\n    function request(url, options = {}) {\n        return {\n            url: url,\n            method: options.method || \"GET\",\n            headers: options.headers ? Object.keys(options.headers).map((k) => ({ key: k, value: options.headers?.[k] || \"\" })) : emptyKeyVal,\n            httpBody: options.body\n        };\n    }\n    exports_1(\"request\", request);\n    function dynamicRequest(request) {\n        return {\n            url: `https://google.com/?ketsu_dynamic=${encodeURIComponent(JSON.stringify(request))}`,\n            method: \"GET\",\n            headers: emptyKeyVal,\n            httpBody: undefined\n        };\n    }\n    function viewsHolder(h) {\n        return {\n            cellDesing: h.design || \"wide5\",\n            defaultLayout: h.distribution || \"wideStrechedFullList\",\n            orientation: h.orientation || \"vertical\",\n            section: {\n                sectionName: h.title || \"\",\n                separator: true\n            },\n            paging: \"leading\",\n            data: h.views || [],\n            layout: undefined,\n        };\n    }\n    exports_1(\"viewsHolder\", viewsHolder);\n    /**\n     * Creates a content view with default values\n     * @param v - Partial view configuration\n     * @returns Complete View object with defaults applied\n     *\n     * @example\n     * const movieView = view({\n     *   title: \"The Matrix\",\n     *   description: \"A computer hacker learns about reality\",\n     *   image: request(\"https://example.com/matrix.jpg\"),\n     *   link: request(\"https://example.com/matrix\")\n     * });\n     */\n    function view(v) {\n        return {\n            link: dynamicRequest(v.link || defaultRequest),\n            image: v.image || defaultImage,\n            title: v.title || \"\",\n            description: v.description || \"\",\n            field1: v.field1 || \"\",\n            field2: v.field2 || \"\",\n            field3: v.field3 || \"\",\n            field4: v.field4 || \"\",\n            isChapter: false,\n            openInWebView: false\n        };\n    }\n    exports_1(\"view\", view);\n    // MARK: MAINPAGE\n    /**\n     * Sets up the main page layout with the provided view holders\n     * @param layout - Array of ViewsHolder objects to display on the main page\n     *\n     * @example\n     * main([\n     *   viewsHolder({ title: \"Featured\", views: featuredViews }),\n     *   viewsHolder({ title: \"Popular\", views: popularViews })\n     * ]);\n     */\n    function main(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"main\", main);\n    // MARK: SEARCHPAGE\n    /**\n     * Sets up the search results page layout\n     * @param layout - Array of ViewsHolder objects to display search results\n     *\n     * @example\n     * search([\n     *   viewsHolder({ title: \"Search Results\", views: searchResults })\n     * ]);\n     */\n    function search(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"search\", search);\n    /**\n     * Retrieves current search metadata (query and page), must be used at the start of the search script.\n     * @param test - Optional test metadata to override URL parsing\n     * @returns Search metadata object\n     *\n     * @example\n     * const { searched, page } = searchMetadata();\n     * console.log(`Searching for: ${searched}, Page: ${page}`);\n     */\n    function searchMetadata(test) {\n        let meta = metadata();\n        let searchMeta = store.get(\"ketsu_search\");\n        if (!searchMeta && meta.request.url.includes(\"?ketsu_search=\")) {\n            let url = new URL(meta.request.url).searchParams;\n            let searched = url.get(\"ketsu_search\") || \"\";\n            let page = parseInt(url.get(\"page\") || \"0\", 10);\n            searchMeta = {\n                searched: test?.searched ? test.searched : searched,\n                page: test?.page ? test.page : page\n            };\n            store.set(\"ketsu_search\", searchMeta);\n        }\n        return searchMeta || { searched: \"\", page: 0 };\n    }\n    exports_1(\"searchMetadata\", searchMetadata);\n    /**\n     * Creates a chapter request object\n     * @param url - Chapter URL\n     * @param options - Chapter configuration options\n     * @returns ChapterRequest object\n     *\n     * @example\n     * const chapter = chapterRequest(\"https://example.com/chapter1\", {\n     *   name: \"Chapter 1: The Beginning\",\n     *   openInWebView: false\n     * });\n     */\n    function chapterRequest(url, options = {}) {\n        return {\n            chapName: options.name,\n            link: dynamicRequest(request(url, options)),\n            openInWebView: options.openInWebView ?? false\n        };\n    }\n    exports_1(\"chapterRequest\", chapterRequest);\n    /**\n     * Sets up an information/detail page\n     * @param data - Partial info page configuration\n     *\n     * @example\n     * info({\n     *   title: \" Some title\",\n     *   description: \"A high school chemistry teacher turned meth cook\",\n     *   genres: [\"Drama\", \"Crime\", \"Thriller\"],\n     *   chapters: [chapter1, chapter2, chapter3]\n     * });\n     */\n    function info(data) {\n        let l = {\n            image: data.image || defaultImage,\n            link: data.link || metadata().request,\n            title: data.title || \"\",\n            description: data.description || \"\",\n            genres: data.genres || [],\n            field1: data.field1 || \"\",\n            field2: data.field2 || \"\",\n            field3: data.field3 || \"\",\n            field4: data.field4 || \"\",\n            chapters: data.chapters || []\n        };\n        metadata().output = l;\n        finish();\n    }\n    exports_1(\"info\", info);\n    /**\n     * Sets up chapter content (videos, images, or text)\n     * @param data - Chapter content data (images, videos, or text string)\n     *\n     * @example\n     * // For image-based content (manga)\n     * chapters([\n     *   request(\"https://example.com/page1.jpg\"),\n     *   request(\"https://example.com/page2.jpg\")\n     * ]);\n     *\n     * @example\n     * // For video content\n     * chapters([\n     *   videoRequest(\"https://example.com/video.mp4\"),\n     *   resolverRequest(\"https://example.com/embed\")\n     * ]);\n     *\n     * @example\n     * // For text content\n     * chapters(\"This is the chapter text content...\");\n     */\n    function chapters(data) {\n        let output = {\n            videos: undefined,\n            text: undefined,\n            images: undefined\n        };\n        if (!Array.isArray(data)) {\n            if (typeof data !== \"string\") {\n                throw new Error(\"Chapters type is wrong\");\n            }\n            output.text = { text: data };\n        }\n        if (Array.isArray(data) && data.some((k) => (\"url\" in k))) {\n            output.images = data;\n        }\n        else if (Array.isArray(data)) {\n            output.videos = {\n                needsResolver: [],\n                rawVideo: []\n            };\n            data.forEach((v) => \"video\" in v ? output.videos.rawVideo.push(v) : output.videos.needsResolver.push(v));\n        }\n        metadata().output = output;\n        finish();\n    }\n    exports_1(\"chapters\", chapters);\n    // MARK: RESOLVE\n    /**\n     * Returns the video resolved from the embeded website.\n     * @param video - VideoRequest object to resolve\n     *\n     * @example\n     * const resolvedVideo = videoRequest(\"https://cdn.example.com/video.mp4\");\n     * resolver(resolvedVideo);\n     */\n    function resolver(video) {\n        metadata().output = video;\n        finish();\n    }\n    exports_1(\"resolver\", resolver);\n    /**\n     * Creates a resolver request for extracting video URLs from embed pages\n     * @param url - URL to the video resolver/embed page\n     * @param options - Resolver configuration options\n     * @returns ResolverRequest object\n     *\n     * @example\n     * const resolver = resolverRequest(\"https://streamwebsite.com/video123\", {\n     *   resolverID: \"STREAMWEBSITE\" //\n     * });\n     */\n    function resolverRequest(url, options) {\n        return {\n            link: dynamicRequest(request(url, options)),\n            resolverIdentifier: options?.resolverID || \"\"\n        };\n    }\n    exports_1(\"resolverRequest\", resolverRequest);\n    /**\n     * Creates a subtitle request\n     * @param url - URL to subtitle file\n     * @param options - Subtitle configuration options\n     * @returns SubsRequest object\n     *\n     * @example\n     * const subtitles = subsRequest(\"https://example.com/subs.vtt\", {\n     *   language: \"English\"\n     * });\n     */\n    function subsRequest(url, options) {\n        return {\n            link: request(url, options),\n            language: options?.language || \"unknown\"\n        };\n    }\n    exports_1(\"subsRequest\", subsRequest);\n    /**\n     * Creates a video request with quality and subtitle options\n     * @param url - Direct video URL\n     * @param options - Video configuration options\n     * @returns VideoRequest object\n     *\n     * @example\n     * const video = videoRequest(\"https://example.com/video.mp4\", {\n     *   quality: \"1080p\",\n     *   subs: [\n     *     subsRequest(\"https://example.com/en.vtt\", { language: \"English\" }),\n     *     subsRequest(\"https://example.com/es.vtt\", { language: \"Spanish\" })\n     *   ]\n     * });\n     */\n    function videoRequest(url, options) {\n        return {\n            video: [{\n                    videoLink: request(url, options),\n                    videoQuality: options?.quality || \"auto\"\n                }],\n            subs: options?.subs\n        };\n    }\n    exports_1(\"videoRequest\", videoRequest);\n    function metadata() {\n        if (!_metadata) {\n            const savedData = document.getElementById('ketsu-final-data');\n            _metadata = JSON.parse(savedData?.textContent || \"\");\n        }\n        return _metadata;\n    }\n    // MARK: Finish\n    function finish() {\n        const savedData = document.getElementById('ketsu-final-data');\n        _metadata ? (savedData.textContent = JSON.stringify(_metadata)) : (undefined);\n        _logs.forEach((l) => action(\"KETSU_LOG\", l));\n        action(\"EXECUTE_KETSU_ASYNC\");\n        throw new Error();\n    }\n    function setExtraInfo(key, value) {\n        let meta = metadata();\n        let kv = meta.extra.extraInfo.find((k) => k.key === key);\n        if (!kv) {\n            kv = {\n                key: \"\",\n                value: \"\"\n            };\n            meta.extra.extraInfo.push(kv);\n        }\n        kv.key = key;\n        kv.value = value;\n    }\n    function setCommand(name, key, value) {\n        let meta = metadata();\n        let command = meta.extra.commands.find((c) => c.commandName == name);\n        if (!command) {\n            command = {\n                commandName: name,\n                params: []\n            };\n            meta.extra.commands.push(command);\n        }\n        command.params.push({ key, value });\n    }\n    function action(name, val = \"\") {\n        if (\"webkit\" in window) {\n            window.webkit.messageHandlers[name].postMessage(val);\n        }\n        else if (name === \"KETSU_LOG\") {\n            console.log(val);\n        }\n    }\n    /**\n     * Logs messages for debugging purposes\n     * @param args - Values to log\n     *\n     * @example\n     * log(\"Debug message\", { data: \"example\" });\n     * log(\"User action:\", userAction, \"Result:\", result);\n     */\n    function log(...args) {\n        const stringifiedArgs = args.map(arg => stringify(arg)).join('\\n\\n');\n        _logs.push(stringifiedArgs);\n    }\n    exports_1(\"log\", log);\n    function stringify(value) {\n        // Primitives\n        if (value === null)\n            return 'null';\n        if (value === undefined)\n            return 'undefined';\n        if (typeof value === 'string')\n            return value;\n        if (typeof value === 'number' || typeof value === 'boolean')\n            return String(value);\n        // Functions\n        if (typeof value === 'function') {\n            return `[Function: ${value.name || 'anonymous'}]`;\n        }\n        // Errors\n        if (value instanceof Error) {\n            return `${value.name}: ${value.message}`;\n        }\n        // Everything else - just stringify with pretty print\n        try {\n            return JSON.stringify(value, (key, val) => {\n                if (typeof val === 'function') {\n                    return `[Function: ${val.name || 'anonymous'}]`;\n                }\n                if (val instanceof Error) {\n                    return `${val.name}: ${val.message}`;\n                }\n                return val;\n            }, 2);\n        }\n        catch (e) {\n            return `[${value.constructor?.name || 'Object'}]`;\n        }\n    }\n    return {\n        setters: [],\n        execute: function () {\n            // MARK:GLOBAL\n            window.KETSU_ASYNC = true;\n            emptyKeyVal = [{ key: \"\", value: \"\" }];\n            defaultImage = request(\"https://www.shutterstock.com/image-vector/default-ui-image-placeholder-wireframes-600nw-1037719192.jpg\");\n            defaultRequest = request(\"https://www.google.com/\");\n            _metadata = undefined;\n            _store = {\n                ...[...metadata().extra.extraInfo, ...metadata().global.variables].reduce((acc, val) => {\n                    acc[val.key] = val.value;\n                    return acc;\n                }, {})\n            };\n            /**\n             * Global storage instance for persisting data\n             *\n             * @example\n             * // Store data\n             * store.set(\"user_preferences\", { theme: \"dark\" });\n             *\n             * // Retrieve data\n             * const prefs = store.get(\"user_preferences\");\n             *\n             * // Check if key exists\n             * if (store.has(\"user_preferences\")) {\n             *   // Key exists\n             * }\n             */\n            exports_1(\"store\", store = {\n                set: (key, value, persist = false) => {\n                    let val = encodeURIComponent(JSON.stringify({ value: value }));\n                    persist ? setCommand(\"persistant\", key, val) : setExtraInfo(key, val);\n                },\n                get: (key) => {\n                    let val = undefined;\n                    try {\n                        val = JSON.parse(decodeURIComponent(_store[key])).value;\n                    }\n                    catch {\n                        log(`key: ${key} not found in the store.`);\n                    }\n                    return val;\n                },\n                has: (key) => (key in _store)\n            });\n            // MARK: LOGS\n            _logs = [];\n        }\n    };\n});\nSystem.register(\"shared\", [\"core\"], function (exports_2, context_2) {\n    \"use strict\";\n    var core;\n    var __moduleName = context_2 && context_2.id;\n    function extractJsonString(text) {\n        // Match the first {...} or [...] block (non-greedy)\n        const match = text.match(/({[\\s\\S]*}|\\[[\\s\\S]*\\])/);\n        return match ? JSON.parse(match[0]) : null;\n    }\n    exports_2(\"extractJsonString\", extractJsonString);\n    /**\n     * Given an array of chapter entries, returns only the preferred group for each chap.\n     * @param {Array} chapters - Array of chapter objects with 'chap' and 'group_name'.\n     * @param {Array} preferredGroups - Array of group names in order of preference.\n     * @returns {Array} Filtered array with only preferred group per chap.\n     */\n    function filterChaptersByPreferredGroup(chapters, preferredGroups) {\n        // Group chapters by chap number\n        const chapMap = new Map();\n        for (const entry of chapters) {\n            const chapNum = entry.chap;\n            if (!chapMap.has(chapNum))\n                chapMap.set(chapNum, []);\n            chapMap.get(chapNum).push(entry);\n        }\n        // For each chap, pick the preferred group\n        const result = [];\n        for (const [chapNum, groupEntries] of chapMap.entries()) {\n            // Sort by preferredGroups order\n            groupEntries.sort((a, b) => {\n                const aIdx = preferredGroups.indexOf(a.group_name);\n                const bIdx = preferredGroups.indexOf(b.group_name);\n                return (aIdx === -1 ? Infinity : aIdx) - (bIdx === -1 ? Infinity : bIdx);\n            });\n            result.push(groupEntries[0]); // Pick the top-ranked group\n        }\n        return result;\n    }\n    exports_2(\"filterChaptersByPreferredGroup\", filterChaptersByPreferredGroup);\n    function ImageService(data) {\n        return core.request('https://meo.comick.pictures/' + data);\n    }\n    exports_2(\"ImageService\", ImageService);\n    function InfoService(data) {\n        return core.request(`https://comick.io/comic/${data}?lang=en`);\n    }\n    exports_2(\"InfoService\", InfoService);\n    return {\n        setters: [\n            function (core_1) {\n                core = core_1;\n            }\n        ],\n        execute: function () {\n        }\n    };\n});\nSystem.register(\"info\", [\"core\", \"shared\"], function (exports_3, context_3) {\n    \"use strict\";\n    var core, shared, res, title, image, description, table, data, hid, chaptersAPI, API_Data, chaptersArray, url, sortedArray;\n    var __moduleName = context_3 && context_3.id;\n    return {\n        setters: [\n            function (core_2) {\n                core = core_2;\n            },\n            function (shared_1) {\n                shared = shared_1;\n            }\n        ],\n        execute: async function () {\n            res = await core.dynamicFetch({ loadInSite: true, removeScripts: false });\n            title = res.querySelector('h1').textContent;\n            image = res.querySelector(`meta[property=\"og:image\"]`).getAttribute('content');\n            description = res.querySelector('div[class^=comic-desc] > p').textContent;\n            table = res.querySelector(\"table.mt-3\").textContent.split(/(?=[A-Z][a-z]+(?:\\s[A-Z][a-z]+)*:)/g);\n            data = Object.fromEntries(table.map((v) => [v.split(\": \")[0], v.split(\": \")[1].split(\", \")]));\n            hid = JSON.parse(res.querySelector('script[id=__NEXT_DATA__]').textContent)['props']['pageProps']['comic']['hid'];\n            chaptersAPI = await core.fetch(`https://api.comick.io/comic/${hid}/chapters?limit=1000`, { headers: { \"Referer\": \"https://comick.io/\" } });\n            API_Data = shared.extractJsonString(chaptersAPI.querySelector('script').textContent);\n            chaptersArray = API_Data ? API_Data['chapters'] : [];\n            url = new URL('https://comick.io' + res.querySelector('meta[property=\"og:url\"]').getAttribute('content'));\n            core.log(url);\n            sortedArray = shared.filterChaptersByPreferredGroup(chaptersArray, ['Asura', 'Official', 'flamecomics']).map(entry => {\n                return core.chapterRequest(`${url}-${entry['hid']}-chapter-${entry['chap']}-en`, { headers: { \"Referer\": \"https://comick.io/\" }, openInWebView: false, name: `Chapter ${entry['chap']}` });\n            });\n            core.info({\n                title: title,\n                image: core.request(image),\n                description: description,\n                genres: data.Genres,\n                chapters: sortedArray\n            });\n        }\n    };\n});\n\n            System.import(\"info\");\n            "},"output":{"image":{"url":"","method":"GET","headers":[{"key":"","value":""}],"httpBody":null},"link":{"url":"","method":"GET","headers":[{"key":"","value":""}],"httpBody":null},"title":"","description":"","genres":[""],"field1":"","field2":"","field3":"","field4":"","chapters":[{"chapName":"","openInWebView":false,"link":{"url":"https://google.com/","method":"GET","headers":[{"key":"key","value":"value"}],"httpBody":null}}]},"fileType":"info","fileSection":"Module","fileID":1303432505,"fileName":"info.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":false},"code":{"route":["javascriptConfig","javaScript"],"name":"Code Editor","data":"import * as core from \"./core\"\nimport * as shared from \"./shared\"\n\ntype ChaptersJson = Record<string, any>;\n\nlet res = await core.dynamicFetch({loadInSite: true, removeScripts: false});\n\nlet title = res.querySelector('h1')!.textContent;\nlet image = res.querySelector(`meta[property=\"og:image\"]`)!.getAttribute('content');\nlet description = res.querySelector('div[class^=comic-desc] > p')!.textContent;\nlet table = res.querySelector(\"table.mt-3\")!.textContent!.split(/(?=[A-Z][a-z]+(?:\\s[A-Z][a-z]+)*:)/g)\nlet data : Record<string,string[]> = Object.fromEntries(table.map((v) => [v.split(\": \")[0],v.split(\": \")[1].split(\", \")] ));\nlet hid = JSON.parse(res.querySelector('script[id=__NEXT_DATA__]')!.textContent!)['props']['pageProps']['comic']['hid'];\nlet chaptersAPI = await core.fetch(`https://api.comick.io/comic/${hid}/chapters?limit=1000`, {headers: {\"Referer\": \"https://comick.io/\"}});\nlet API_Data = shared.extractJsonString(chaptersAPI.querySelector('script')!.textContent!) as ChaptersJson;\n\nlet chaptersArray : Array<Record<string, any>> = API_Data ? API_Data['chapters'] : [];\n\nlet url = new URL('https://comick.io' + res.querySelector('meta[property=\"og:url\"]')!.getAttribute('content')); core.log(url);\nlet sortedArray : any = shared.filterChaptersByPreferredGroup(chaptersArray, ['Asura', 'Official', 'flamecomics']).map(entry => {\n    return core.chapterRequest(`${url}-${entry['hid']}-chapter-${entry['chap']}-en`, {headers: {\"Referer\": \"https://comick.io/\"},openInWebView: false, name: `Chapter ${entry['chap']}`})\n});\n\ncore.info({\n    title : title as string,\n    image : core.request(image as string),\n    description : description as string,\n    genres : data.Genres,\n    chapters : sortedArray\n});","type":"typescript","compiled":true,"status":true,"shared":false,"line":30}},"fileIndexPath":[5,0]}],"chapters":[{"request":{"url":"https://google.com","method":"GET","headers":[{"key":"","value":""}]},"extra":{"commands":[{"commandName":"","params":[{"key":"","value":""}]}],"extraInfo":[{"key":"","value":""}]},"javascriptConfig":{"removeJavascript":true,"loadInWebView":false,"javaScript":"\n            var System = (function() {\n  var modules = {};\n  \n  function register(name, deps, declare) {\n      modules[name] = { deps: deps, declare: declare };\n  }\n  \n  function getModule(name) {\n      var module = modules[name];\n      if (!module) throw new Error('Module ' + name + ' not found');\n      if (module.exports) return module.exports;\n      \n      var exports = {};\n      var context = { id: name };\n      \n      // Create a function to export values\n      function exportFn(key, value) {\n          if (arguments.length === 1) {\n              Object.assign(exports, key);\n          } else {\n              exports[key] = value;\n          }\n      }\n      \n      var setters = [];\n      var depExports = [];\n      \n      // Load dependencies first\n      for (var i = 0; i < module.deps.length; i++) {\n          if (module.deps[i] !== 'exports') {\n              depExports.push(getModule(module.deps[i]));\n          }\n      }\n      \n      // Call the module declaration\n      var declared = module.declare(exportFn, context);\n      \n      // Call setters with loaded dependencies\n      if (declared.setters) {\n          var depIndex = 0;\n          for (var i = 0; i < declared.setters.length; i++) {\n              if (declared.setters[i]) {\n                  declared.setters[i](depExports[depIndex++]);\n              }\n          }\n      }\n      \n      // Execute the module\n      if (declared.execute) {\n          declared.execute();\n      }\n      \n      module.exports = exports;\n      return exports;\n  }\n  \n  return {\n      register: register,\n      import: function(name) { \n          getModule(name);\n      }\n  };\n})();\n\n            System.register(\"core\", [], function (exports_1, context_1) {\n    \"use strict\";\n    var emptyKeyVal, defaultImage, defaultRequest, _metadata, _store, store, _logs;\n    var __moduleName = context_1 && context_1.id;\n    /**\n     * Makes an HTTP request to a website, you can also run javascript directly on the website.\n     * @param url - The URL to fetch\n     * @param options - Fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Simple fetch\n     * const html = await fetch(\"https://example.com\");\n     *\n     * @example\n     * // Fetch and execute code in site context\n     * const result = await fetch(\"https://example.com\", {}, (window) => {\n     *   return window.document.title;\n     * });\n     */\n    async function fetch(url, options = {}, ...run) {\n        let meta = metadata();\n        let metaUrl = meta.request.url;\n        if (url === metaUrl) {\n            let res = run.length > 0 ? await run[0]?.(window) : window.document.documentElement.outerHTML;\n            store.set(url, res);\n            return run.length > 0 ? res : window.document.documentElement;\n        }\n        let cached = store.get(url);\n        if (cached === undefined) {\n            meta.request = request(url, options);\n            meta.javascriptConfig.loadInWebView = options.loadInSite ?? false;\n            meta.javascriptConfig.removeJavascript = options.removeScripts ?? false;\n            return finish();\n        }\n        return (typeof cached === \"string\" && cached.trim().startsWith('<')) ?\n            (new DOMParser()).parseFromString(cached, \"text/html\").documentElement :\n            cached;\n    }\n    exports_1(\"fetch\", fetch);\n    /**\n     * Same as fetch but used on parts of the module where the Request is dynamic, must be used at first of the Info, Chapters and Resolvers scripts.\n     * @param options - Dynamic fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Dynamic fetch with test URL\n     * const result = await dynamicFetch({ testURL: \"https://api.example.com\" });\n     */\n    async function dynamicFetch(_options = {}, ...run) {\n        let meta = metadata();\n        let currentURL = meta.request.url;\n        let url = store.get(\"ketsu_dynamic\");\n        let options = _options;\n        if (options.testURL) {\n            url = options.testURL;\n        }\n        if (!url) {\n            if (!currentURL.includes(\"ketsu_dynamic=\")) {\n                throw new Error(\"No dynamic URL available and no testURL provided.\");\n            }\n            const encoded = currentURL.split(\"ketsu_dynamic=\")[1];\n            const originalRequest = JSON.parse(decodeURIComponent(encoded));\n            url = originalRequest.url;\n            // Merge headers/body/method only if not already defined\n            options.method ?? (options.method = originalRequest.method);\n            options.body ?? (options.body = originalRequest.httpBody);\n            const originalHeaders = Object.fromEntries(originalRequest.headers.map(kv => [kv.key, kv.value]));\n            options.headers = {\n                ...originalHeaders,\n                ...options.headers\n            };\n            // Save resolved URL to prevent repeating decoding later\n            store.set(\"ketsu_dynamic\", url);\n        }\n        return fetch(url, options, ...run);\n    }\n    exports_1(\"dynamicFetch\", dynamicFetch);\n    function toast(text) {\n        action(\"KETSU_MSG\", text);\n    }\n    exports_1(\"toast\", toast);\n    // MARK: REQUEST\n    /**\n     * Creates a request object for KETSU\n     * @param url - The target URL\n     * @param options - Request configuration options\n     * @returns Request object formatted for the Ketsu framework\n     *\n     * @example\n     * const req = request(\"https://api.example.com\", {\n     *   method: \"POST\",\n     *   headers: { \"Content-Type\": \"application/json\" },\n     *   body: JSON.stringify({ data: \"example\" })\n     * });\n     */\n    function request(url, options = {}) {\n        return {\n            url: url,\n            method: options.method || \"GET\",\n            headers: options.headers ? Object.keys(options.headers).map((k) => ({ key: k, value: options.headers?.[k] || \"\" })) : emptyKeyVal,\n            httpBody: options.body\n        };\n    }\n    exports_1(\"request\", request);\n    function dynamicRequest(request) {\n        return {\n            url: `https://google.com/?ketsu_dynamic=${encodeURIComponent(JSON.stringify(request))}`,\n            method: \"GET\",\n            headers: emptyKeyVal,\n            httpBody: undefined\n        };\n    }\n    function viewsHolder(h) {\n        return {\n            cellDesing: h.design || \"wide5\",\n            defaultLayout: h.distribution || \"wideStrechedFullList\",\n            orientation: h.orientation || \"vertical\",\n            section: {\n                sectionName: h.title || \"\",\n                separator: true\n            },\n            paging: \"leading\",\n            data: h.views || [],\n            layout: undefined,\n        };\n    }\n    exports_1(\"viewsHolder\", viewsHolder);\n    /**\n     * Creates a content view with default values\n     * @param v - Partial view configuration\n     * @returns Complete View object with defaults applied\n     *\n     * @example\n     * const movieView = view({\n     *   title: \"The Matrix\",\n     *   description: \"A computer hacker learns about reality\",\n     *   image: request(\"https://example.com/matrix.jpg\"),\n     *   link: request(\"https://example.com/matrix\")\n     * });\n     */\n    function view(v) {\n        return {\n            link: dynamicRequest(v.link || defaultRequest),\n            image: v.image || defaultImage,\n            title: v.title || \"\",\n            description: v.description || \"\",\n            field1: v.field1 || \"\",\n            field2: v.field2 || \"\",\n            field3: v.field3 || \"\",\n            field4: v.field4 || \"\",\n            isChapter: false,\n            openInWebView: false\n        };\n    }\n    exports_1(\"view\", view);\n    // MARK: MAINPAGE\n    /**\n     * Sets up the main page layout with the provided view holders\n     * @param layout - Array of ViewsHolder objects to display on the main page\n     *\n     * @example\n     * main([\n     *   viewsHolder({ title: \"Featured\", views: featuredViews }),\n     *   viewsHolder({ title: \"Popular\", views: popularViews })\n     * ]);\n     */\n    function main(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"main\", main);\n    // MARK: SEARCHPAGE\n    /**\n     * Sets up the search results page layout\n     * @param layout - Array of ViewsHolder objects to display search results\n     *\n     * @example\n     * search([\n     *   viewsHolder({ title: \"Search Results\", views: searchResults })\n     * ]);\n     */\n    function search(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"search\", search);\n    /**\n     * Retrieves current search metadata (query and page), must be used at the start of the search script.\n     * @param test - Optional test metadata to override URL parsing\n     * @returns Search metadata object\n     *\n     * @example\n     * const { searched, page } = searchMetadata();\n     * console.log(`Searching for: ${searched}, Page: ${page}`);\n     */\n    function searchMetadata(test) {\n        let meta = metadata();\n        let searchMeta = store.get(\"ketsu_search\");\n        if (!searchMeta && meta.request.url.includes(\"?ketsu_search=\")) {\n            let url = new URL(meta.request.url).searchParams;\n            let searched = url.get(\"ketsu_search\") || \"\";\n            let page = parseInt(url.get(\"page\") || \"0\", 10);\n            searchMeta = {\n                searched: test?.searched ? test.searched : searched,\n                page: test?.page ? test.page : page\n            };\n            store.set(\"ketsu_search\", searchMeta);\n        }\n        return searchMeta || { searched: \"\", page: 0 };\n    }\n    exports_1(\"searchMetadata\", searchMetadata);\n    /**\n     * Creates a chapter request object\n     * @param url - Chapter URL\n     * @param options - Chapter configuration options\n     * @returns ChapterRequest object\n     *\n     * @example\n     * const chapter = chapterRequest(\"https://example.com/chapter1\", {\n     *   name: \"Chapter 1: The Beginning\",\n     *   openInWebView: false\n     * });\n     */\n    function chapterRequest(url, options = {}) {\n        return {\n            chapName: options.name,\n            link: dynamicRequest(request(url, options)),\n            openInWebView: options.openInWebView ?? false\n        };\n    }\n    exports_1(\"chapterRequest\", chapterRequest);\n    /**\n     * Sets up an information/detail page\n     * @param data - Partial info page configuration\n     *\n     * @example\n     * info({\n     *   title: \" Some title\",\n     *   description: \"A high school chemistry teacher turned meth cook\",\n     *   genres: [\"Drama\", \"Crime\", \"Thriller\"],\n     *   chapters: [chapter1, chapter2, chapter3]\n     * });\n     */\n    function info(data) {\n        let l = {\n            image: data.image || defaultImage,\n            link: data.link || metadata().request,\n            title: data.title || \"\",\n            description: data.description || \"\",\n            genres: data.genres || [],\n            field1: data.field1 || \"\",\n            field2: data.field2 || \"\",\n            field3: data.field3 || \"\",\n            field4: data.field4 || \"\",\n            chapters: data.chapters || []\n        };\n        metadata().output = l;\n        finish();\n    }\n    exports_1(\"info\", info);\n    /**\n     * Sets up chapter content (videos, images, or text)\n     * @param data - Chapter content data (images, videos, or text string)\n     *\n     * @example\n     * // For image-based content (manga)\n     * chapters([\n     *   request(\"https://example.com/page1.jpg\"),\n     *   request(\"https://example.com/page2.jpg\")\n     * ]);\n     *\n     * @example\n     * // For video content\n     * chapters([\n     *   videoRequest(\"https://example.com/video.mp4\"),\n     *   resolverRequest(\"https://example.com/embed\")\n     * ]);\n     *\n     * @example\n     * // For text content\n     * chapters(\"This is the chapter text content...\");\n     */\n    function chapters(data) {\n        let output = {\n            videos: undefined,\n            text: undefined,\n            images: undefined\n        };\n        if (!Array.isArray(data)) {\n            if (typeof data !== \"string\") {\n                throw new Error(\"Chapters type is wrong\");\n            }\n            output.text = { text: data };\n        }\n        if (Array.isArray(data) && data.some((k) => (\"url\" in k))) {\n            output.images = data;\n        }\n        else if (Array.isArray(data)) {\n            output.videos = {\n                needsResolver: [],\n                rawVideo: []\n            };\n            data.forEach((v) => \"video\" in v ? output.videos.rawVideo.push(v) : output.videos.needsResolver.push(v));\n        }\n        metadata().output = output;\n        finish();\n    }\n    exports_1(\"chapters\", chapters);\n    // MARK: RESOLVE\n    /**\n     * Returns the video resolved from the embeded website.\n     * @param video - VideoRequest object to resolve\n     *\n     * @example\n     * const resolvedVideo = videoRequest(\"https://cdn.example.com/video.mp4\");\n     * resolver(resolvedVideo);\n     */\n    function resolver(video) {\n        metadata().output = video;\n        finish();\n    }\n    exports_1(\"resolver\", resolver);\n    /**\n     * Creates a resolver request for extracting video URLs from embed pages\n     * @param url - URL to the video resolver/embed page\n     * @param options - Resolver configuration options\n     * @returns ResolverRequest object\n     *\n     * @example\n     * const resolver = resolverRequest(\"https://streamwebsite.com/video123\", {\n     *   resolverID: \"STREAMWEBSITE\" //\n     * });\n     */\n    function resolverRequest(url, options) {\n        return {\n            link: dynamicRequest(request(url, options)),\n            resolverIdentifier: options?.resolverID || \"\"\n        };\n    }\n    exports_1(\"resolverRequest\", resolverRequest);\n    /**\n     * Creates a subtitle request\n     * @param url - URL to subtitle file\n     * @param options - Subtitle configuration options\n     * @returns SubsRequest object\n     *\n     * @example\n     * const subtitles = subsRequest(\"https://example.com/subs.vtt\", {\n     *   language: \"English\"\n     * });\n     */\n    function subsRequest(url, options) {\n        return {\n            link: request(url, options),\n            language: options?.language || \"unknown\"\n        };\n    }\n    exports_1(\"subsRequest\", subsRequest);\n    /**\n     * Creates a video request with quality and subtitle options\n     * @param url - Direct video URL\n     * @param options - Video configuration options\n     * @returns VideoRequest object\n     *\n     * @example\n     * const video = videoRequest(\"https://example.com/video.mp4\", {\n     *   quality: \"1080p\",\n     *   subs: [\n     *     subsRequest(\"https://example.com/en.vtt\", { language: \"English\" }),\n     *     subsRequest(\"https://example.com/es.vtt\", { language: \"Spanish\" })\n     *   ]\n     * });\n     */\n    function videoRequest(url, options) {\n        return {\n            video: [{\n                    videoLink: request(url, options),\n                    videoQuality: options?.quality || \"auto\"\n                }],\n            subs: options?.subs\n        };\n    }\n    exports_1(\"videoRequest\", videoRequest);\n    function metadata() {\n        if (!_metadata) {\n            const savedData = document.getElementById('ketsu-final-data');\n            _metadata = JSON.parse(savedData?.textContent || \"\");\n        }\n        return _metadata;\n    }\n    // MARK: Finish\n    function finish() {\n        const savedData = document.getElementById('ketsu-final-data');\n        _metadata ? (savedData.textContent = JSON.stringify(_metadata)) : (undefined);\n        _logs.forEach((l) => action(\"KETSU_LOG\", l));\n        action(\"EXECUTE_KETSU_ASYNC\");\n        throw new Error();\n    }\n    function setExtraInfo(key, value) {\n        let meta = metadata();\n        let kv = meta.extra.extraInfo.find((k) => k.key === key);\n        if (!kv) {\n            kv = {\n                key: \"\",\n                value: \"\"\n            };\n            meta.extra.extraInfo.push(kv);\n        }\n        kv.key = key;\n        kv.value = value;\n    }\n    function setCommand(name, key, value) {\n        let meta = metadata();\n        let command = meta.extra.commands.find((c) => c.commandName == name);\n        if (!command) {\n            command = {\n                commandName: name,\n                params: []\n            };\n            meta.extra.commands.push(command);\n        }\n        command.params.push({ key, value });\n    }\n    function action(name, val = \"\") {\n        if (\"webkit\" in window) {\n            window.webkit.messageHandlers[name].postMessage(val);\n        }\n        else if (name === \"KETSU_LOG\") {\n            console.log(val);\n        }\n    }\n    /**\n     * Logs messages for debugging purposes\n     * @param args - Values to log\n     *\n     * @example\n     * log(\"Debug message\", { data: \"example\" });\n     * log(\"User action:\", userAction, \"Result:\", result);\n     */\n    function log(...args) {\n        const stringifiedArgs = args.map(arg => stringify(arg)).join('\\n\\n');\n        _logs.push(stringifiedArgs);\n    }\n    exports_1(\"log\", log);\n    function stringify(value) {\n        // Primitives\n        if (value === null)\n            return 'null';\n        if (value === undefined)\n            return 'undefined';\n        if (typeof value === 'string')\n            return value;\n        if (typeof value === 'number' || typeof value === 'boolean')\n            return String(value);\n        // Functions\n        if (typeof value === 'function') {\n            return `[Function: ${value.name || 'anonymous'}]`;\n        }\n        // Errors\n        if (value instanceof Error) {\n            return `${value.name}: ${value.message}`;\n        }\n        // Everything else - just stringify with pretty print\n        try {\n            return JSON.stringify(value, (key, val) => {\n                if (typeof val === 'function') {\n                    return `[Function: ${val.name || 'anonymous'}]`;\n                }\n                if (val instanceof Error) {\n                    return `${val.name}: ${val.message}`;\n                }\n                return val;\n            }, 2);\n        }\n        catch (e) {\n            return `[${value.constructor?.name || 'Object'}]`;\n        }\n    }\n    return {\n        setters: [],\n        execute: function () {\n            // MARK:GLOBAL\n            window.KETSU_ASYNC = true;\n            emptyKeyVal = [{ key: \"\", value: \"\" }];\n            defaultImage = request(\"https://www.shutterstock.com/image-vector/default-ui-image-placeholder-wireframes-600nw-1037719192.jpg\");\n            defaultRequest = request(\"https://www.google.com/\");\n            _metadata = undefined;\n            _store = {\n                ...[...metadata().extra.extraInfo, ...metadata().global.variables].reduce((acc, val) => {\n                    acc[val.key] = val.value;\n                    return acc;\n                }, {})\n            };\n            /**\n             * Global storage instance for persisting data\n             *\n             * @example\n             * // Store data\n             * store.set(\"user_preferences\", { theme: \"dark\" });\n             *\n             * // Retrieve data\n             * const prefs = store.get(\"user_preferences\");\n             *\n             * // Check if key exists\n             * if (store.has(\"user_preferences\")) {\n             *   // Key exists\n             * }\n             */\n            exports_1(\"store\", store = {\n                set: (key, value, persist = false) => {\n                    let val = encodeURIComponent(JSON.stringify({ value: value }));\n                    persist ? setCommand(\"persistant\", key, val) : setExtraInfo(key, val);\n                },\n                get: (key) => {\n                    let val = undefined;\n                    try {\n                        val = JSON.parse(decodeURIComponent(_store[key])).value;\n                    }\n                    catch {\n                        log(`key: ${key} not found in the store.`);\n                    }\n                    return val;\n                },\n                has: (key) => (key in _store)\n            });\n            // MARK: LOGS\n            _logs = [];\n        }\n    };\n});\nSystem.register(\"shared\", [\"core\"], function (exports_2, context_2) {\n    \"use strict\";\n    var core;\n    var __moduleName = context_2 && context_2.id;\n    function extractJsonString(text) {\n        // Match the first {...} or [...] block (non-greedy)\n        const match = text.match(/({[\\s\\S]*}|\\[[\\s\\S]*\\])/);\n        return match ? JSON.parse(match[0]) : null;\n    }\n    exports_2(\"extractJsonString\", extractJsonString);\n    /**\n     * Given an array of chapter entries, returns only the preferred group for each chap.\n     * @param {Array} chapters - Array of chapter objects with 'chap' and 'group_name'.\n     * @param {Array} preferredGroups - Array of group names in order of preference.\n     * @returns {Array} Filtered array with only preferred group per chap.\n     */\n    function filterChaptersByPreferredGroup(chapters, preferredGroups) {\n        // Group chapters by chap number\n        const chapMap = new Map();\n        for (const entry of chapters) {\n            const chapNum = entry.chap;\n            if (!chapMap.has(chapNum))\n                chapMap.set(chapNum, []);\n            chapMap.get(chapNum).push(entry);\n        }\n        // For each chap, pick the preferred group\n        const result = [];\n        for (const [chapNum, groupEntries] of chapMap.entries()) {\n            // Sort by preferredGroups order\n            groupEntries.sort((a, b) => {\n                const aIdx = preferredGroups.indexOf(a.group_name);\n                const bIdx = preferredGroups.indexOf(b.group_name);\n                return (aIdx === -1 ? Infinity : aIdx) - (bIdx === -1 ? Infinity : bIdx);\n            });\n            result.push(groupEntries[0]); // Pick the top-ranked group\n        }\n        return result;\n    }\n    exports_2(\"filterChaptersByPreferredGroup\", filterChaptersByPreferredGroup);\n    function ImageService(data) {\n        return core.request('https://meo.comick.pictures/' + data);\n    }\n    exports_2(\"ImageService\", ImageService);\n    function InfoService(data) {\n        return core.request(`https://comick.io/comic/${data}?lang=en`);\n    }\n    exports_2(\"InfoService\", InfoService);\n    return {\n        setters: [\n            function (core_1) {\n                core = core_1;\n            }\n        ],\n        execute: function () {\n        }\n    };\n});\nSystem.register(\"chapters\", [\"core\", \"shared\"], function (exports_3, context_3) {\n    \"use strict\";\n    var core, shared_1, request, chapterData, images;\n    var __moduleName = context_3 && context_3.id;\n    return {\n        setters: [\n            function (core_2) {\n                core = core_2;\n            },\n            function (shared_1_1) {\n                shared_1 = shared_1_1;\n            }\n        ],\n        execute: async function () {\n            request = await core.dynamicFetch({ loadInSite: true, removeScripts: true });\n            chapterData = JSON.parse(request.querySelector('[id=__NEXT_DATA__]').textContent)['props']['pageProps']['chapter'];\n            images = chapterData['md_images'].map((entry) => {\n                return core.request(shared_1.ImageService(entry['b2key']));\n            });\n            core.chapters(images);\n        }\n    };\n});\n\n            System.import(\"chapters\");\n            "},"output":{"videos":{"needsResolver":[{"resolverIdentifier":"","link":{"url":"","method":"GET","headers":[{"key":"key","value":"value"}],"httpBody":null}}],"rawVideo":[{"video":[{"videoQuality":"","videoLink":{"url":"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4","method":"GET","headers":[{"key":"key","value":"value"}],"httpBody":null}}]}]},"images":[{"url":"empty","method":"GET","headers":[{"key":"key","value":"value"}],"httpBody":null}],"text":{"text":""}},"fileType":"chapters","fileSection":"Module","fileID":2241182013,"fileName":"chapters.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":false},"code":{"route":["javascriptConfig","javaScript"],"name":"Code Editor","data":"import * as core from \"./core\"\nimport {ImageService} from \"./shared\";\n\nlet request = await core.dynamicFetch({loadInSite: true, removeScripts: true});\n\nlet chapterData = JSON.parse(request.querySelector('[id=__NEXT_DATA__]')!.textContent!)['props']['pageProps']['chapter'];\n\nlet images = chapterData['md_images'].map((entry: any) => {\n    return core.request(ImageService(entry['b2key']));\n})\n\ncore.chapters(images) ","type":"typescript","compiled":true,"status":true,"shared":false,"line":12}},"fileIndexPath":[6,0]}],"moduleResolvers":[{"resolverInfo":{"resolverName":"","nameMatches":[""],"developer":"","moduleID":"","resolverVersion":1,"baseURL":""},"resolver":[{"request":{"url":"https://google.com","method":"GET","headers":[{"key":"","value":""}]},"extra":{"commands":[{"commandName":"","params":[{"key":"","value":""}]}],"extraInfo":[{"key":"","value":""}]},"javascriptConfig":{"removeJavascript":false,"loadInWebView":false,"javaScript":"\n            var System = (function() {\n  var modules = {};\n  \n  function register(name, deps, declare) {\n      modules[name] = { deps: deps, declare: declare };\n  }\n  \n  function getModule(name) {\n      var module = modules[name];\n      if (!module) throw new Error('Module ' + name + ' not found');\n      if (module.exports) return module.exports;\n      \n      var exports = {};\n      var context = { id: name };\n      \n      // Create a function to export values\n      function exportFn(key, value) {\n          if (arguments.length === 1) {\n              Object.assign(exports, key);\n          } else {\n              exports[key] = value;\n          }\n      }\n      \n      var setters = [];\n      var depExports = [];\n      \n      // Load dependencies first\n      for (var i = 0; i < module.deps.length; i++) {\n          if (module.deps[i] !== 'exports') {\n              depExports.push(getModule(module.deps[i]));\n          }\n      }\n      \n      // Call the module declaration\n      var declared = module.declare(exportFn, context);\n      \n      // Call setters with loaded dependencies\n      if (declared.setters) {\n          var depIndex = 0;\n          for (var i = 0; i < declared.setters.length; i++) {\n              if (declared.setters[i]) {\n                  declared.setters[i](depExports[depIndex++]);\n              }\n          }\n      }\n      \n      // Execute the module\n      if (declared.execute) {\n          declared.execute();\n      }\n      \n      module.exports = exports;\n      return exports;\n  }\n  \n  return {\n      register: register,\n      import: function(name) { \n          getModule(name);\n      }\n  };\n})();\n\n            System.register(\"core\", [], function (exports_1, context_1) {\n    \"use strict\";\n    var emptyKeyVal, defaultImage, defaultRequest, _metadata, _store, store, _logs;\n    var __moduleName = context_1 && context_1.id;\n    /**\n     * Makes an HTTP request to a website, you can also run javascript directly on the website.\n     * @param url - The URL to fetch\n     * @param options - Fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Simple fetch\n     * const html = await fetch(\"https://example.com\");\n     *\n     * @example\n     * // Fetch and execute code in site context\n     * const result = await fetch(\"https://example.com\", {}, (window) => {\n     *   return window.document.title;\n     * });\n     */\n    async function fetch(url, options = {}, ...run) {\n        let meta = metadata();\n        let metaUrl = meta.request.url;\n        if (url === metaUrl) {\n            let res = run.length > 0 ? await run[0]?.(window) : window.document.documentElement.outerHTML;\n            store.set(url, res);\n            return run.length > 0 ? res : window.document.documentElement;\n        }\n        let cached = store.get(url);\n        if (cached === undefined) {\n            meta.request = request(url, options);\n            meta.javascriptConfig.loadInWebView = options.loadInSite ?? false;\n            meta.javascriptConfig.removeJavascript = options.removeScripts ?? false;\n            return finish();\n        }\n        return (typeof cached === \"string\" && cached.trim().startsWith('<')) ?\n            (new DOMParser()).parseFromString(cached, \"text/html\").documentElement :\n            cached;\n    }\n    exports_1(\"fetch\", fetch);\n    /**\n     * Same as fetch but used on parts of the module where the Request is dynamic, must be used at first of the Info, Chapters and Resolvers scripts.\n     * @param options - Dynamic fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Dynamic fetch with test URL\n     * const result = await dynamicFetch({ testURL: \"https://api.example.com\" });\n     */\n    async function dynamicFetch(_options = {}, ...run) {\n        let meta = metadata();\n        let currentURL = meta.request.url;\n        let url = store.get(\"ketsu_dynamic\");\n        let options = _options;\n        if (options.testURL) {\n            url = options.testURL;\n        }\n        if (!url) {\n            if (!currentURL.includes(\"ketsu_dynamic=\")) {\n                throw new Error(\"No dynamic URL available and no testURL provided.\");\n            }\n            const encoded = currentURL.split(\"ketsu_dynamic=\")[1];\n            const originalRequest = JSON.parse(decodeURIComponent(encoded));\n            url = originalRequest.url;\n            // Merge headers/body/method only if not already defined\n            options.method ?? (options.method = originalRequest.method);\n            options.body ?? (options.body = originalRequest.httpBody);\n            const originalHeaders = Object.fromEntries(originalRequest.headers.map(kv => [kv.key, kv.value]));\n            options.headers = {\n                ...originalHeaders,\n                ...options.headers\n            };\n            // Save resolved URL to prevent repeating decoding later\n            store.set(\"ketsu_dynamic\", url);\n        }\n        return fetch(url, options, ...run);\n    }\n    exports_1(\"dynamicFetch\", dynamicFetch);\n    function toast(text) {\n        action(\"KETSU_MSG\", text);\n    }\n    exports_1(\"toast\", toast);\n    // MARK: REQUEST\n    /**\n     * Creates a request object for KETSU\n     * @param url - The target URL\n     * @param options - Request configuration options\n     * @returns Request object formatted for the Ketsu framework\n     *\n     * @example\n     * const req = request(\"https://api.example.com\", {\n     *   method: \"POST\",\n     *   headers: { \"Content-Type\": \"application/json\" },\n     *   body: JSON.stringify({ data: \"example\" })\n     * });\n     */\n    function request(url, options = {}) {\n        return {\n            url: url,\n            method: options.method || \"GET\",\n            headers: options.headers ? Object.keys(options.headers).map((k) => ({ key: k, value: options.headers?.[k] || \"\" })) : emptyKeyVal,\n            httpBody: options.body\n        };\n    }\n    exports_1(\"request\", request);\n    function dynamicRequest(request) {\n        return {\n            url: `https://google.com/?ketsu_dynamic=${encodeURIComponent(JSON.stringify(request))}`,\n            method: \"GET\",\n            headers: emptyKeyVal,\n            httpBody: undefined\n        };\n    }\n    function viewsHolder(h) {\n        return {\n            cellDesing: h.design || \"wide5\",\n            defaultLayout: h.distribution || \"wideStrechedFullList\",\n            orientation: h.orientation || \"vertical\",\n            section: {\n                sectionName: h.title || \"\",\n                separator: true\n            },\n            paging: \"leading\",\n            data: h.views || [],\n            layout: undefined,\n        };\n    }\n    exports_1(\"viewsHolder\", viewsHolder);\n    /**\n     * Creates a content view with default values\n     * @param v - Partial view configuration\n     * @returns Complete View object with defaults applied\n     *\n     * @example\n     * const movieView = view({\n     *   title: \"The Matrix\",\n     *   description: \"A computer hacker learns about reality\",\n     *   image: request(\"https://example.com/matrix.jpg\"),\n     *   link: request(\"https://example.com/matrix\")\n     * });\n     */\n    function view(v) {\n        return {\n            link: dynamicRequest(v.link || defaultRequest),\n            image: v.image || defaultImage,\n            title: v.title || \"\",\n            description: v.description || \"\",\n            field1: v.field1 || \"\",\n            field2: v.field2 || \"\",\n            field3: v.field3 || \"\",\n            field4: v.field4 || \"\",\n            isChapter: false,\n            openInWebView: false\n        };\n    }\n    exports_1(\"view\", view);\n    // MARK: MAINPAGE\n    /**\n     * Sets up the main page layout with the provided view holders\n     * @param layout - Array of ViewsHolder objects to display on the main page\n     *\n     * @example\n     * main([\n     *   viewsHolder({ title: \"Featured\", views: featuredViews }),\n     *   viewsHolder({ title: \"Popular\", views: popularViews })\n     * ]);\n     */\n    function main(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"main\", main);\n    // MARK: SEARCHPAGE\n    /**\n     * Sets up the search results page layout\n     * @param layout - Array of ViewsHolder objects to display search results\n     *\n     * @example\n     * search([\n     *   viewsHolder({ title: \"Search Results\", views: searchResults })\n     * ]);\n     */\n    function search(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"search\", search);\n    /**\n     * Retrieves current search metadata (query and page), must be used at the start of the search script.\n     * @param test - Optional test metadata to override URL parsing\n     * @returns Search metadata object\n     *\n     * @example\n     * const { searched, page } = searchMetadata();\n     * console.log(`Searching for: ${searched}, Page: ${page}`);\n     */\n    function searchMetadata(test) {\n        let meta = metadata();\n        let searchMeta = store.get(\"ketsu_search\");\n        if (!searchMeta && meta.request.url.includes(\"?ketsu_search=\")) {\n            let url = new URL(meta.request.url).searchParams;\n            let searched = url.get(\"ketsu_search\") || \"\";\n            let page = parseInt(url.get(\"page\") || \"0\", 10);\n            searchMeta = {\n                searched: test?.searched ? test.searched : searched,\n                page: test?.page ? test.page : page\n            };\n            store.set(\"ketsu_search\", searchMeta);\n        }\n        return searchMeta || { searched: \"\", page: 0 };\n    }\n    exports_1(\"searchMetadata\", searchMetadata);\n    /**\n     * Creates a chapter request object\n     * @param url - Chapter URL\n     * @param options - Chapter configuration options\n     * @returns ChapterRequest object\n     *\n     * @example\n     * const chapter = chapterRequest(\"https://example.com/chapter1\", {\n     *   name: \"Chapter 1: The Beginning\",\n     *   openInWebView: false\n     * });\n     */\n    function chapterRequest(url, options = {}) {\n        return {\n            chapName: options.name,\n            link: dynamicRequest(request(url, options)),\n            openInWebView: options.openInWebView ?? false\n        };\n    }\n    exports_1(\"chapterRequest\", chapterRequest);\n    /**\n     * Sets up an information/detail page\n     * @param data - Partial info page configuration\n     *\n     * @example\n     * info({\n     *   title: \" Some title\",\n     *   description: \"A high school chemistry teacher turned meth cook\",\n     *   genres: [\"Drama\", \"Crime\", \"Thriller\"],\n     *   chapters: [chapter1, chapter2, chapter3]\n     * });\n     */\n    function info(data) {\n        let l = {\n            image: data.image || defaultImage,\n            link: data.link || metadata().request,\n            title: data.title || \"\",\n            description: data.description || \"\",\n            genres: data.genres || [],\n            field1: data.field1 || \"\",\n            field2: data.field2 || \"\",\n            field3: data.field3 || \"\",\n            field4: data.field4 || \"\",\n            chapters: data.chapters || []\n        };\n        metadata().output = l;\n        finish();\n    }\n    exports_1(\"info\", info);\n    /**\n     * Sets up chapter content (videos, images, or text)\n     * @param data - Chapter content data (images, videos, or text string)\n     *\n     * @example\n     * // For image-based content (manga)\n     * chapters([\n     *   request(\"https://example.com/page1.jpg\"),\n     *   request(\"https://example.com/page2.jpg\")\n     * ]);\n     *\n     * @example\n     * // For video content\n     * chapters([\n     *   videoRequest(\"https://example.com/video.mp4\"),\n     *   resolverRequest(\"https://example.com/embed\")\n     * ]);\n     *\n     * @example\n     * // For text content\n     * chapters(\"This is the chapter text content...\");\n     */\n    function chapters(data) {\n        let output = {\n            videos: undefined,\n            text: undefined,\n            images: undefined\n        };\n        if (!Array.isArray(data)) {\n            if (typeof data !== \"string\") {\n                throw new Error(\"Chapters type is wrong\");\n            }\n            output.text = { text: data };\n        }\n        if (Array.isArray(data) && data.some((k) => (\"url\" in k))) {\n            output.images = data;\n        }\n        else if (Array.isArray(data)) {\n            output.videos = {\n                needsResolver: [],\n                rawVideo: []\n            };\n            data.forEach((v) => \"video\" in v ? output.videos.rawVideo.push(v) : output.videos.needsResolver.push(v));\n        }\n        metadata().output = output;\n        finish();\n    }\n    exports_1(\"chapters\", chapters);\n    // MARK: RESOLVE\n    /**\n     * Returns the video resolved from the embeded website.\n     * @param video - VideoRequest object to resolve\n     *\n     * @example\n     * const resolvedVideo = videoRequest(\"https://cdn.example.com/video.mp4\");\n     * resolver(resolvedVideo);\n     */\n    function resolver(video) {\n        metadata().output = video;\n        finish();\n    }\n    exports_1(\"resolver\", resolver);\n    /**\n     * Creates a resolver request for extracting video URLs from embed pages\n     * @param url - URL to the video resolver/embed page\n     * @param options - Resolver configuration options\n     * @returns ResolverRequest object\n     *\n     * @example\n     * const resolver = resolverRequest(\"https://streamwebsite.com/video123\", {\n     *   resolverID: \"STREAMWEBSITE\" //\n     * });\n     */\n    function resolverRequest(url, options) {\n        return {\n            link: dynamicRequest(request(url, options)),\n            resolverIdentifier: options?.resolverID || \"\"\n        };\n    }\n    exports_1(\"resolverRequest\", resolverRequest);\n    /**\n     * Creates a subtitle request\n     * @param url - URL to subtitle file\n     * @param options - Subtitle configuration options\n     * @returns SubsRequest object\n     *\n     * @example\n     * const subtitles = subsRequest(\"https://example.com/subs.vtt\", {\n     *   language: \"English\"\n     * });\n     */\n    function subsRequest(url, options) {\n        return {\n            link: request(url, options),\n            language: options?.language || \"unknown\"\n        };\n    }\n    exports_1(\"subsRequest\", subsRequest);\n    /**\n     * Creates a video request with quality and subtitle options\n     * @param url - Direct video URL\n     * @param options - Video configuration options\n     * @returns VideoRequest object\n     *\n     * @example\n     * const video = videoRequest(\"https://example.com/video.mp4\", {\n     *   quality: \"1080p\",\n     *   subs: [\n     *     subsRequest(\"https://example.com/en.vtt\", { language: \"English\" }),\n     *     subsRequest(\"https://example.com/es.vtt\", { language: \"Spanish\" })\n     *   ]\n     * });\n     */\n    function videoRequest(url, options) {\n        return {\n            video: [{\n                    videoLink: request(url, options),\n                    videoQuality: options?.quality || \"auto\"\n                }],\n            subs: options?.subs\n        };\n    }\n    exports_1(\"videoRequest\", videoRequest);\n    function metadata() {\n        if (!_metadata) {\n            const savedData = document.getElementById('ketsu-final-data');\n            _metadata = JSON.parse(savedData?.textContent || \"\");\n        }\n        return _metadata;\n    }\n    // MARK: Finish\n    function finish() {\n        const savedData = document.getElementById('ketsu-final-data');\n        _metadata ? (savedData.textContent = JSON.stringify(_metadata)) : (undefined);\n        _logs.forEach((l) => action(\"KETSU_LOG\", l));\n        action(\"EXECUTE_KETSU_ASYNC\");\n        throw new Error();\n    }\n    function setExtraInfo(key, value) {\n        let meta = metadata();\n        let kv = meta.extra.extraInfo.find((k) => k.key === key);\n        if (!kv) {\n            kv = {\n                key: \"\",\n                value: \"\"\n            };\n            meta.extra.extraInfo.push(kv);\n        }\n        kv.key = key;\n        kv.value = value;\n    }\n    function setCommand(name, key, value) {\n        let meta = metadata();\n        let command = meta.extra.commands.find((c) => c.commandName == name);\n        if (!command) {\n            command = {\n                commandName: name,\n                params: []\n            };\n            meta.extra.commands.push(command);\n        }\n        command.params.push({ key, value });\n    }\n    function action(name, val = \"\") {\n        if (\"webkit\" in window) {\n            window.webkit.messageHandlers[name].postMessage(val);\n        }\n        else if (name === \"KETSU_LOG\") {\n            console.log(val);\n        }\n    }\n    /**\n     * Logs messages for debugging purposes\n     * @param args - Values to log\n     *\n     * @example\n     * log(\"Debug message\", { data: \"example\" });\n     * log(\"User action:\", userAction, \"Result:\", result);\n     */\n    function log(...args) {\n        const stringifiedArgs = args.map(arg => stringify(arg)).join('\\n\\n');\n        _logs.push(stringifiedArgs);\n    }\n    exports_1(\"log\", log);\n    function stringify(value) {\n        // Primitives\n        if (value === null)\n            return 'null';\n        if (value === undefined)\n            return 'undefined';\n        if (typeof value === 'string')\n            return value;\n        if (typeof value === 'number' || typeof value === 'boolean')\n            return String(value);\n        // Functions\n        if (typeof value === 'function') {\n            return `[Function: ${value.name || 'anonymous'}]`;\n        }\n        // Errors\n        if (value instanceof Error) {\n            return `${value.name}: ${value.message}`;\n        }\n        // Everything else - just stringify with pretty print\n        try {\n            return JSON.stringify(value, (key, val) => {\n                if (typeof val === 'function') {\n                    return `[Function: ${val.name || 'anonymous'}]`;\n                }\n                if (val instanceof Error) {\n                    return `${val.name}: ${val.message}`;\n                }\n                return val;\n            }, 2);\n        }\n        catch (e) {\n            return `[${value.constructor?.name || 'Object'}]`;\n        }\n    }\n    return {\n        setters: [],\n        execute: function () {\n            // MARK:GLOBAL\n            window.KETSU_ASYNC = true;\n            emptyKeyVal = [{ key: \"\", value: \"\" }];\n            defaultImage = request(\"https://www.shutterstock.com/image-vector/default-ui-image-placeholder-wireframes-600nw-1037719192.jpg\");\n            defaultRequest = request(\"https://www.google.com/\");\n            _metadata = undefined;\n            _store = {\n                ...[...metadata().extra.extraInfo, ...metadata().global.variables].reduce((acc, val) => {\n                    acc[val.key] = val.value;\n                    return acc;\n                }, {})\n            };\n            /**\n             * Global storage instance for persisting data\n             *\n             * @example\n             * // Store data\n             * store.set(\"user_preferences\", { theme: \"dark\" });\n             *\n             * // Retrieve data\n             * const prefs = store.get(\"user_preferences\");\n             *\n             * // Check if key exists\n             * if (store.has(\"user_preferences\")) {\n             *   // Key exists\n             * }\n             */\n            exports_1(\"store\", store = {\n                set: (key, value, persist = false) => {\n                    let val = encodeURIComponent(JSON.stringify({ value: value }));\n                    persist ? setCommand(\"persistant\", key, val) : setExtraInfo(key, val);\n                },\n                get: (key) => {\n                    let val = undefined;\n                    try {\n                        val = JSON.parse(decodeURIComponent(_store[key])).value;\n                    }\n                    catch {\n                        log(`key: ${key} not found in the store.`);\n                    }\n                    return val;\n                },\n                has: (key) => (key in _store)\n            });\n            // MARK: LOGS\n            _logs = [];\n        }\n    };\n});\nSystem.register(\"moduleResolvers\", [\"core\"], function (exports_2, context_2) {\n    \"use strict\";\n    var core;\n    var __moduleName = context_2 && context_2.id;\n    return {\n        setters: [\n            function (core_1) {\n                core = core_1;\n            }\n        ],\n        execute: function () {\n            core.log(\"hello\");\n            core.resolver(core.videoRequest(\"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"));\n        }\n    };\n});\n\n            System.import(\"moduleResolvers\");\n            "},"output":{"moduleID":"","video":[{"videoQuality":"720","videoLink":{"url":"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4","method":"GET","headers":[{"key":"key","value":"value"}],"httpBody":null}}]}}],"fileType":"moduleResolvers","fileSection":"Resolvers","fileID":4087012470,"fileName":"moduleResolvers.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":false},"code":{"route":["resolver",0,"javascriptConfig","javaScript"],"name":"Code Editor","data":"import * as core from \"./core\"\n\ncore.log(\"hello\")\n\n\ncore.resolver(core.videoRequest(\"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"))","type":"typescript","compiled":true,"status":false,"shared":false,"line":6},"params":{"name":"Settings Editor","route":["resolverInfo"],"status":true}},"fileIndexPath":[7,0]},{"resolverInfo":{"resolverName":"","nameMatches":[""],"developer":"","moduleID":"","resolverVersion":1,"baseURL":""},"resolver":[{"request":{"url":"https://google.com","method":"GET","headers":[{"key":"","value":""}]},"extra":{"commands":[{"commandName":"","params":[{"key":"","value":""}]}],"extraInfo":[{"key":"","value":""}]},"javascriptConfig":{"removeJavascript":false,"loadInWebView":false,"javaScript":"\n            var System = (function() {\n  var modules = {};\n  \n  function register(name, deps, declare) {\n      modules[name] = { deps: deps, declare: declare };\n  }\n  \n  function getModule(name) {\n      var module = modules[name];\n      if (!module) throw new Error('Module ' + name + ' not found');\n      if (module.exports) return module.exports;\n      \n      var exports = {};\n      var context = { id: name };\n      \n      // Create a function to export values\n      function exportFn(key, value) {\n          if (arguments.length === 1) {\n              Object.assign(exports, key);\n          } else {\n              exports[key] = value;\n          }\n      }\n      \n      var setters = [];\n      var depExports = [];\n      \n      // Load dependencies first\n      for (var i = 0; i < module.deps.length; i++) {\n          if (module.deps[i] !== 'exports') {\n              depExports.push(getModule(module.deps[i]));\n          }\n      }\n      \n      // Call the module declaration\n      var declared = module.declare(exportFn, context);\n      \n      // Call setters with loaded dependencies\n      if (declared.setters) {\n          var depIndex = 0;\n          for (var i = 0; i < declared.setters.length; i++) {\n              if (declared.setters[i]) {\n                  declared.setters[i](depExports[depIndex++]);\n              }\n          }\n      }\n      \n      // Execute the module\n      if (declared.execute) {\n          declared.execute();\n      }\n      \n      module.exports = exports;\n      return exports;\n  }\n  \n  return {\n      register: register,\n      import: function(name) { \n          getModule(name);\n      }\n  };\n})();\n\n            System.register(\"core\", [], function (exports_1, context_1) {\n    \"use strict\";\n    var emptyKeyVal, defaultImage, defaultRequest, _metadata, _store, store, _logs;\n    var __moduleName = context_1 && context_1.id;\n    /**\n     * Makes an HTTP request to a website, you can also run javascript directly on the website.\n     * @param url - The URL to fetch\n     * @param options - Fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Simple fetch\n     * const html = await fetch(\"https://example.com\");\n     *\n     * @example\n     * // Fetch and execute code in site context\n     * const result = await fetch(\"https://example.com\", {}, (window) => {\n     *   return window.document.title;\n     * });\n     */\n    async function fetch(url, options = {}, ...run) {\n        let meta = metadata();\n        let metaUrl = meta.request.url;\n        if (url === metaUrl) {\n            let res = run.length > 0 ? await run[0]?.(window) : window.document.documentElement.outerHTML;\n            store.set(url, res);\n            return run.length > 0 ? res : window.document.documentElement;\n        }\n        let cached = store.get(url);\n        if (cached === undefined) {\n            meta.request = request(url, options);\n            meta.javascriptConfig.loadInWebView = options.loadInSite ?? false;\n            meta.javascriptConfig.removeJavascript = options.removeScripts ?? false;\n            return finish();\n        }\n        return (typeof cached === \"string\" && cached.trim().startsWith('<')) ?\n            (new DOMParser()).parseFromString(cached, \"text/html\").documentElement :\n            cached;\n    }\n    exports_1(\"fetch\", fetch);\n    /**\n     * Same as fetch but used on parts of the module where the Request is dynamic, must be used at first of the Info, Chapters and Resolvers scripts.\n     * @param options - Dynamic fetch configuration options\n     * @param run - Optional function to execute within the fetched site's context\n     * @returns Promise resolving to either HTML element or the result of the run function\n     *\n     * @example\n     * // Dynamic fetch with test URL\n     * const result = await dynamicFetch({ testURL: \"https://api.example.com\" });\n     */\n    async function dynamicFetch(_options = {}, ...run) {\n        let meta = metadata();\n        let currentURL = meta.request.url;\n        let url = store.get(\"ketsu_dynamic\");\n        let options = _options;\n        if (options.testURL) {\n            url = options.testURL;\n        }\n        if (!url) {\n            if (!currentURL.includes(\"ketsu_dynamic=\")) {\n                throw new Error(\"No dynamic URL available and no testURL provided.\");\n            }\n            const encoded = currentURL.split(\"ketsu_dynamic=\")[1];\n            const originalRequest = JSON.parse(decodeURIComponent(encoded));\n            url = originalRequest.url;\n            // Merge headers/body/method only if not already defined\n            options.method ?? (options.method = originalRequest.method);\n            options.body ?? (options.body = originalRequest.httpBody);\n            const originalHeaders = Object.fromEntries(originalRequest.headers.map(kv => [kv.key, kv.value]));\n            options.headers = {\n                ...originalHeaders,\n                ...options.headers\n            };\n            // Save resolved URL to prevent repeating decoding later\n            store.set(\"ketsu_dynamic\", url);\n        }\n        return fetch(url, options, ...run);\n    }\n    exports_1(\"dynamicFetch\", dynamicFetch);\n    function toast(text) {\n        action(\"KETSU_MSG\", text);\n    }\n    exports_1(\"toast\", toast);\n    // MARK: REQUEST\n    /**\n     * Creates a request object for KETSU\n     * @param url - The target URL\n     * @param options - Request configuration options\n     * @returns Request object formatted for the Ketsu framework\n     *\n     * @example\n     * const req = request(\"https://api.example.com\", {\n     *   method: \"POST\",\n     *   headers: { \"Content-Type\": \"application/json\" },\n     *   body: JSON.stringify({ data: \"example\" })\n     * });\n     */\n    function request(url, options = {}) {\n        return {\n            url: url,\n            method: options.method || \"GET\",\n            headers: options.headers ? Object.keys(options.headers).map((k) => ({ key: k, value: options.headers?.[k] || \"\" })) : emptyKeyVal,\n            httpBody: options.body\n        };\n    }\n    exports_1(\"request\", request);\n    function dynamicRequest(request) {\n        return {\n            url: `https://google.com/?ketsu_dynamic=${encodeURIComponent(JSON.stringify(request))}`,\n            method: \"GET\",\n            headers: emptyKeyVal,\n            httpBody: undefined\n        };\n    }\n    function viewsHolder(h) {\n        return {\n            cellDesing: h.design || \"wide5\",\n            defaultLayout: h.distribution || \"wideStrechedFullList\",\n            orientation: h.orientation || \"vertical\",\n            section: {\n                sectionName: h.title || \"\",\n                separator: true\n            },\n            paging: \"leading\",\n            data: h.views || [],\n            layout: undefined,\n        };\n    }\n    exports_1(\"viewsHolder\", viewsHolder);\n    /**\n     * Creates a content view with default values\n     * @param v - Partial view configuration\n     * @returns Complete View object with defaults applied\n     *\n     * @example\n     * const movieView = view({\n     *   title: \"The Matrix\",\n     *   description: \"A computer hacker learns about reality\",\n     *   image: request(\"https://example.com/matrix.jpg\"),\n     *   link: request(\"https://example.com/matrix\")\n     * });\n     */\n    function view(v) {\n        return {\n            link: dynamicRequest(v.link || defaultRequest),\n            image: v.image || defaultImage,\n            title: v.title || \"\",\n            description: v.description || \"\",\n            field1: v.field1 || \"\",\n            field2: v.field2 || \"\",\n            field3: v.field3 || \"\",\n            field4: v.field4 || \"\",\n            isChapter: false,\n            openInWebView: false\n        };\n    }\n    exports_1(\"view\", view);\n    // MARK: MAINPAGE\n    /**\n     * Sets up the main page layout with the provided view holders\n     * @param layout - Array of ViewsHolder objects to display on the main page\n     *\n     * @example\n     * main([\n     *   viewsHolder({ title: \"Featured\", views: featuredViews }),\n     *   viewsHolder({ title: \"Popular\", views: popularViews })\n     * ]);\n     */\n    function main(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"main\", main);\n    // MARK: SEARCHPAGE\n    /**\n     * Sets up the search results page layout\n     * @param layout - Array of ViewsHolder objects to display search results\n     *\n     * @example\n     * search([\n     *   viewsHolder({ title: \"Search Results\", views: searchResults })\n     * ]);\n     */\n    function search(layout) {\n        metadata().output = layout;\n        finish();\n    }\n    exports_1(\"search\", search);\n    /**\n     * Retrieves current search metadata (query and page), must be used at the start of the search script.\n     * @param test - Optional test metadata to override URL parsing\n     * @returns Search metadata object\n     *\n     * @example\n     * const { searched, page } = searchMetadata();\n     * console.log(`Searching for: ${searched}, Page: ${page}`);\n     */\n    function searchMetadata(test) {\n        let meta = metadata();\n        let searchMeta = store.get(\"ketsu_search\");\n        if (!searchMeta && meta.request.url.includes(\"?ketsu_search=\")) {\n            let url = new URL(meta.request.url).searchParams;\n            let searched = url.get(\"ketsu_search\") || \"\";\n            let page = parseInt(url.get(\"page\") || \"0\", 10);\n            searchMeta = {\n                searched: test?.searched ? test.searched : searched,\n                page: test?.page ? test.page : page\n            };\n            store.set(\"ketsu_search\", searchMeta);\n        }\n        return searchMeta || { searched: \"\", page: 0 };\n    }\n    exports_1(\"searchMetadata\", searchMetadata);\n    /**\n     * Creates a chapter request object\n     * @param url - Chapter URL\n     * @param options - Chapter configuration options\n     * @returns ChapterRequest object\n     *\n     * @example\n     * const chapter = chapterRequest(\"https://example.com/chapter1\", {\n     *   name: \"Chapter 1: The Beginning\",\n     *   openInWebView: false\n     * });\n     */\n    function chapterRequest(url, options = {}) {\n        return {\n            chapName: options.name,\n            link: dynamicRequest(request(url, options)),\n            openInWebView: options.openInWebView ?? false\n        };\n    }\n    exports_1(\"chapterRequest\", chapterRequest);\n    /**\n     * Sets up an information/detail page\n     * @param data - Partial info page configuration\n     *\n     * @example\n     * info({\n     *   title: \" Some title\",\n     *   description: \"A high school chemistry teacher turned meth cook\",\n     *   genres: [\"Drama\", \"Crime\", \"Thriller\"],\n     *   chapters: [chapter1, chapter2, chapter3]\n     * });\n     */\n    function info(data) {\n        let l = {\n            image: data.image || defaultImage,\n            link: data.link || metadata().request,\n            title: data.title || \"\",\n            description: data.description || \"\",\n            genres: data.genres || [],\n            field1: data.field1 || \"\",\n            field2: data.field2 || \"\",\n            field3: data.field3 || \"\",\n            field4: data.field4 || \"\",\n            chapters: data.chapters || []\n        };\n        metadata().output = l;\n        finish();\n    }\n    exports_1(\"info\", info);\n    /**\n     * Sets up chapter content (videos, images, or text)\n     * @param data - Chapter content data (images, videos, or text string)\n     *\n     * @example\n     * // For image-based content (manga)\n     * chapters([\n     *   request(\"https://example.com/page1.jpg\"),\n     *   request(\"https://example.com/page2.jpg\")\n     * ]);\n     *\n     * @example\n     * // For video content\n     * chapters([\n     *   videoRequest(\"https://example.com/video.mp4\"),\n     *   resolverRequest(\"https://example.com/embed\")\n     * ]);\n     *\n     * @example\n     * // For text content\n     * chapters(\"This is the chapter text content...\");\n     */\n    function chapters(data) {\n        let output = {\n            videos: undefined,\n            text: undefined,\n            images: undefined\n        };\n        if (!Array.isArray(data)) {\n            if (typeof data !== \"string\") {\n                throw new Error(\"Chapters type is wrong\");\n            }\n            output.text = { text: data };\n        }\n        if (Array.isArray(data) && data.some((k) => (\"url\" in k))) {\n            output.images = data;\n        }\n        else if (Array.isArray(data)) {\n            output.videos = {\n                needsResolver: [],\n                rawVideo: []\n            };\n            data.forEach((v) => \"video\" in v ? output.videos.rawVideo.push(v) : output.videos.needsResolver.push(v));\n        }\n        metadata().output = output;\n        finish();\n    }\n    exports_1(\"chapters\", chapters);\n    // MARK: RESOLVE\n    /**\n     * Returns the video resolved from the embeded website.\n     * @param video - VideoRequest object to resolve\n     *\n     * @example\n     * const resolvedVideo = videoRequest(\"https://cdn.example.com/video.mp4\");\n     * resolver(resolvedVideo);\n     */\n    function resolver(video) {\n        metadata().output = video;\n        finish();\n    }\n    exports_1(\"resolver\", resolver);\n    /**\n     * Creates a resolver request for extracting video URLs from embed pages\n     * @param url - URL to the video resolver/embed page\n     * @param options - Resolver configuration options\n     * @returns ResolverRequest object\n     *\n     * @example\n     * const resolver = resolverRequest(\"https://streamwebsite.com/video123\", {\n     *   resolverID: \"STREAMWEBSITE\" //\n     * });\n     */\n    function resolverRequest(url, options) {\n        return {\n            link: dynamicRequest(request(url, options)),\n            resolverIdentifier: options?.resolverID || \"\"\n        };\n    }\n    exports_1(\"resolverRequest\", resolverRequest);\n    /**\n     * Creates a subtitle request\n     * @param url - URL to subtitle file\n     * @param options - Subtitle configuration options\n     * @returns SubsRequest object\n     *\n     * @example\n     * const subtitles = subsRequest(\"https://example.com/subs.vtt\", {\n     *   language: \"English\"\n     * });\n     */\n    function subsRequest(url, options) {\n        return {\n            link: request(url, options),\n            language: options?.language || \"unknown\"\n        };\n    }\n    exports_1(\"subsRequest\", subsRequest);\n    /**\n     * Creates a video request with quality and subtitle options\n     * @param url - Direct video URL\n     * @param options - Video configuration options\n     * @returns VideoRequest object\n     *\n     * @example\n     * const video = videoRequest(\"https://example.com/video.mp4\", {\n     *   quality: \"1080p\",\n     *   subs: [\n     *     subsRequest(\"https://example.com/en.vtt\", { language: \"English\" }),\n     *     subsRequest(\"https://example.com/es.vtt\", { language: \"Spanish\" })\n     *   ]\n     * });\n     */\n    function videoRequest(url, options) {\n        return {\n            video: [{\n                    videoLink: request(url, options),\n                    videoQuality: options?.quality || \"auto\"\n                }],\n            subs: options?.subs\n        };\n    }\n    exports_1(\"videoRequest\", videoRequest);\n    function metadata() {\n        if (!_metadata) {\n            const savedData = document.getElementById('ketsu-final-data');\n            _metadata = JSON.parse(savedData?.textContent || \"\");\n        }\n        return _metadata;\n    }\n    // MARK: Finish\n    function finish() {\n        const savedData = document.getElementById('ketsu-final-data');\n        _metadata ? (savedData.textContent = JSON.stringify(_metadata)) : (undefined);\n        _logs.forEach((l) => action(\"KETSU_LOG\", l));\n        action(\"EXECUTE_KETSU_ASYNC\");\n        throw new Error();\n    }\n    function setExtraInfo(key, value) {\n        let meta = metadata();\n        let kv = meta.extra.extraInfo.find((k) => k.key === key);\n        if (!kv) {\n            kv = {\n                key: \"\",\n                value: \"\"\n            };\n            meta.extra.extraInfo.push(kv);\n        }\n        kv.key = key;\n        kv.value = value;\n    }\n    function setCommand(name, key, value) {\n        let meta = metadata();\n        let command = meta.extra.commands.find((c) => c.commandName == name);\n        if (!command) {\n            command = {\n                commandName: name,\n                params: []\n            };\n            meta.extra.commands.push(command);\n        }\n        command.params.push({ key, value });\n    }\n    function action(name, val = \"\") {\n        if (\"webkit\" in window) {\n            window.webkit.messageHandlers[name].postMessage(val);\n        }\n        else if (name === \"KETSU_LOG\") {\n            console.log(val);\n        }\n    }\n    /**\n     * Logs messages for debugging purposes\n     * @param args - Values to log\n     *\n     * @example\n     * log(\"Debug message\", { data: \"example\" });\n     * log(\"User action:\", userAction, \"Result:\", result);\n     */\n    function log(...args) {\n        const stringifiedArgs = args.map(arg => stringify(arg)).join('\\n\\n');\n        _logs.push(stringifiedArgs);\n    }\n    exports_1(\"log\", log);\n    function stringify(value) {\n        // Primitives\n        if (value === null)\n            return 'null';\n        if (value === undefined)\n            return 'undefined';\n        if (typeof value === 'string')\n            return value;\n        if (typeof value === 'number' || typeof value === 'boolean')\n            return String(value);\n        // Functions\n        if (typeof value === 'function') {\n            return `[Function: ${value.name || 'anonymous'}]`;\n        }\n        // Errors\n        if (value instanceof Error) {\n            return `${value.name}: ${value.message}`;\n        }\n        // Everything else - just stringify with pretty print\n        try {\n            return JSON.stringify(value, (key, val) => {\n                if (typeof val === 'function') {\n                    return `[Function: ${val.name || 'anonymous'}]`;\n                }\n                if (val instanceof Error) {\n                    return `${val.name}: ${val.message}`;\n                }\n                return val;\n            }, 2);\n        }\n        catch (e) {\n            return `[${value.constructor?.name || 'Object'}]`;\n        }\n    }\n    return {\n        setters: [],\n        execute: function () {\n            // MARK:GLOBAL\n            window.KETSU_ASYNC = true;\n            emptyKeyVal = [{ key: \"\", value: \"\" }];\n            defaultImage = request(\"https://www.shutterstock.com/image-vector/default-ui-image-placeholder-wireframes-600nw-1037719192.jpg\");\n            defaultRequest = request(\"https://www.google.com/\");\n            _metadata = undefined;\n            _store = {\n                ...[...metadata().extra.extraInfo, ...metadata().global.variables].reduce((acc, val) => {\n                    acc[val.key] = val.value;\n                    return acc;\n                }, {})\n            };\n            /**\n             * Global storage instance for persisting data\n             *\n             * @example\n             * // Store data\n             * store.set(\"user_preferences\", { theme: \"dark\" });\n             *\n             * // Retrieve data\n             * const prefs = store.get(\"user_preferences\");\n             *\n             * // Check if key exists\n             * if (store.has(\"user_preferences\")) {\n             *   // Key exists\n             * }\n             */\n            exports_1(\"store\", store = {\n                set: (key, value, persist = false) => {\n                    let val = encodeURIComponent(JSON.stringify({ value: value }));\n                    persist ? setCommand(\"persistant\", key, val) : setExtraInfo(key, val);\n                },\n                get: (key) => {\n                    let val = undefined;\n                    try {\n                        val = JSON.parse(decodeURIComponent(_store[key])).value;\n                    }\n                    catch {\n                        log(`key: ${key} not found in the store.`);\n                    }\n                    return val;\n                },\n                has: (key) => (key in _store)\n            });\n            // MARK: LOGS\n            _logs = [];\n        }\n    };\n});\nSystem.register(\"2116698741\", [\"core\"], function (exports_2, context_2) {\n    \"use strict\";\n    var core;\n    var __moduleName = context_2 && context_2.id;\n    return {\n        setters: [\n            function (core_1) {\n                core = core_1;\n            }\n        ],\n        execute: function () {\n            core.log(\"wtf\");\n            core.resolver(core.videoRequest(\"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"));\n        }\n    };\n});\n\n            System.import(\"2116698741\");\n            "},"output":{"moduleID":"","video":[{"videoQuality":"720","videoLink":{"url":"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4","method":"GET","headers":[{"key":"key","value":"value"}],"httpBody":null}}]}}],"fileIndexPath":[7,1],"fileType":"moduleResolvers","fileSection":"Resolvers","fileID":2116698741,"fileName":"2116698741.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":false},"code":{"route":["resolver",0,"javascriptConfig","javaScript"],"name":"Code Editor","data":"import * as core from \"./core\"\n\n\ncore.log(\"wtf\")\n\ncore.resolver(core.videoRequest(\"http://commondatastorage.googleapis.com/gtv-videos-bucket/sample/BigBuckBunny.mp4\"))","compiled":true,"status":false,"shared":false,"line":6},"params":{"name":"Settings Editor","route":["resolverInfo"],"status":true}}}],"responseCodeFunctions":[{"code":0,"msgTitle":"","msgBody":"","type":"normal","functions":[{"request":{"url":"https://google.com","method":"GET","headers":[{"key":"","value":""}]},"extra":{"commands":[{"commandName":"","params":[{"key":"","value":""}]}],"extraInfo":[{"key":"","value":""}]},"javascriptConfig":{"removeJavascript":true,"loadInWebView":false,"javaScript":""}}],"fileType":"responseCodeFunctions","fileSection":"Helpers","fileID":2061855769,"fileName":"responseCodeFunctions.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":true}}}],"helperFunctions":[{"functionName":"example","msgTitle":"","msgBody":"","type":"normal","functions":[{"request":{"url":"https://google.com","method":"GET","headers":[{"key":"","value":""}]},"extra":{"commands":[{"commandName":"","params":[{"key":"","value":""}]}],"extraInfo":[{"key":"","value":""}]},"javascriptConfig":{"removeJavascript":true,"loadInWebView":false,"javaScript":"\n        try {\n\n            /* JAVASCRIPT STARTS */ \n /* JAVASCRIPT ENDS */\n\n        } catch (e) {\n            console.error(e.message);\n\n            if (typeof KETSU_ASYNC !== 'undefined') {\n                window.webkit.messageHandlers.EXECUTE_KETSU_ASYNC.postMessage('');\n            }\n\n        }\n        \n        "}}],"fileType":"helperFunctions","fileSection":"Helpers","fileID":3330151581,"fileName":"helperFunctions.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":true}}}],"moduleCreator":{"currentFile":2253367988,"name":""},"core":{"compiledJS":"","fileType":"core","fileSection":"Shared","fileID":2698950564,"fileName":"core.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":false},"code":{"route":["compiledJS"],"name":"Code Editor","data":"// MARK:GLOBAL\n(window as any).KETSU_ASYNC = true\nconst emptyKeyVal: KeyValue[] = [{ key: \"\", value: \"\" }]\n\n/**\n * Ketsu Framework - A TypeScript/JavaScript framework to simplify KETSU module making.\n * \n * This framework provides utilities for:\n * - Making HTTP requests with caching and site loading capabilities\n * - Creating UI layouts and views for content display\n * - Handling different page types (main, search, info, chapters)\n * - Managing video content with resolvers and subtitles\n * - Storing and retrieving data\n * - Logging and debugging\n */\n\n\n// MARK: TYPE HELPERS\n\ntype Prettify<T> = { [K in keyof T]: T[K] } & {}\n\n// MARK: REQUEST\n\ntype FetchMethods = \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\" | \"HEAD\" | \"OPTIONS\" | \"CONNECT\" | \"TRACE\";\n\n/**\n * Standard fetch options for HTTP requests\n */\ninterface FetchOptions {\n    /** HTTP method to use (default: \"GET\") */\n    method?: FetchMethods;\n    /** Request headers as key-value object */\n    headers?: Record<string, string>;\n    /** Request body content */\n    body?: string;\n}\n\n/**\n * Extended fetch options with Ketsu-specific features\n */\ninterface KetsuFetchOptions extends FetchOptions {\n    /** Whether to remove JavaScript from fetched HTML (default: false) */\n    removeScripts?: boolean;\n    /** Whether to load the content within the site's webview (default: false) */\n    loadInSite?: boolean;\n}\n\n/**\n * Function that runs within a fetched site's context\n */\ntype RunWithinSite<T extends any = any> = [run?: (window: Window) => T]\n\n/**\n * Extracts the return type from an async function\n */\ntype ResolveAsync<T> = T extends Promise<infer R> ? R : T\n\n/**\n * Extracts the return type from a function\n */\ntype ExtractReturnType<T> = T extends ((...args: any[]) => infer U) ? ResolveAsync<U> : never\n\n/**\n * Makes an HTTP request to a website, you can also run javascript directly on the website.\n * @param url - The URL to fetch\n * @param options - Fetch configuration options\n * @param run - Optional function to execute within the fetched site's context\n * @returns Promise resolving to either HTML element or the result of the run function\n * \n * @example\n * // Simple fetch\n * const html = await fetch(\"https://example.com\");\n * \n * @example\n * // Fetch and execute code in site context\n * const result = await fetch(\"https://example.com\", {}, (window) => {\n *   return window.document.title;\n * });\n */\nexport async function fetch<T extends RunWithinSite>(\n    url: string,\n    options: Prettify<KetsuFetchOptions> = {},\n    ...run: T\n): Promise<T extends [] ? HTMLElement : ExtractReturnType<T[0]>> {\n    let meta = metadata()\n    let metaUrl = meta.request.url\n    if (url === metaUrl) {\n        let res = run.length > 0 ? await run[0]?.(window) : window.document.documentElement.outerHTML\n        store.set(url, res)\n        return run.length > 0 ? res : window.document.documentElement\n    }\n    let cached = store.get(url)\n    if (cached === undefined) {\n        meta.request = request(url, options)\n        meta.javascriptConfig.loadInWebView = options.loadInSite ?? false\n        meta.javascriptConfig.removeJavascript = options.removeScripts ?? false\n        return finish() as any\n    }\n    return (typeof cached === \"string\" && cached.trim().startsWith('<')) ?\n        (new DOMParser()).parseFromString(cached, \"text/html\").documentElement as any :\n        cached as any\n}\n\n/**\n * Extended fetch options for dynamic requests\n */\ninterface DynamicFetchOptions extends KetsuFetchOptions {\n    /** Test URL to use instead of dynamic resolution */\n    testURL?: string;\n}\n\n/**\n * Same as fetch but used on parts of the module where the Request is dynamic, must be used at first of the Info, Chapters and Resolvers scripts.\n * @param options - Dynamic fetch configuration options\n * @param run - Optional function to execute within the fetched site's context\n * @returns Promise resolving to either HTML element or the result of the run function\n * \n * @example\n * // Dynamic fetch with test URL\n * const result = await dynamicFetch({ testURL: \"https://api.example.com\" });\n */\nexport async function dynamicFetch<T extends RunWithinSite>(\n    _options: Prettify<DynamicFetchOptions> = {},\n    ...run: T\n): Promise<T extends [] ? HTMLElement : ExtractReturnType<T[0]>> {\n    let meta = metadata();\n    let currentURL = meta.request.url;\n    let url: string | undefined = store.get(\"ketsu_dynamic\");\n    let options = _options;\n\n    if (options.testURL) {\n        url = options.testURL;\n    }\n\n    if (!url) {\n        if (!currentURL.includes(\"ketsu_dynamic=\")) {\n            throw new Error(\"No dynamic URL available and no testURL provided.\");\n        }\n\n        const encoded = currentURL.split(\"ketsu_dynamic=\")[1];\n        const originalRequest: Request = JSON.parse(decodeURIComponent(encoded));\n\n        url = originalRequest.url;\n\n        // Merge headers/body/method only if not already defined\n        options.method ??= originalRequest.method;\n        options.body ??= originalRequest.httpBody;\n        const originalHeaders = Object.fromEntries(originalRequest.headers.map(kv => [kv.key, kv.value]));\n        options.headers = {\n            ...originalHeaders,\n            ...options.headers\n        };\n        // Save resolved URL to prevent repeating decoding later\n        store.set(\"ketsu_dynamic\", url);\n    }\n\n    return fetch(url, options, ...run);\n}\n\n\nexport function toast(text: string): void {\n    action(\"KETSU_MSG\", text)\n}\n\n// MARK: REQUEST\n\n/**\n * Creates a request object for KETSU\n * @param url - The target URL\n * @param options - Request configuration options\n * @returns Request object formatted for the Ketsu framework\n * \n * @example\n * const req = request(\"https://api.example.com\", {\n *   method: \"POST\",\n *   headers: { \"Content-Type\": \"application/json\" },\n *   body: JSON.stringify({ data: \"example\" })\n * });\n */\nexport function request(url: string, options: Prettify<FetchOptions> = {}): Request {\n    return {\n        url: url,\n        method: options.method || \"GET\",\n        headers: options.headers ? Object.keys(options.headers).map((k) => ({ key: k, value: options.headers?.[k] || \"\" })) : emptyKeyVal,\n        httpBody: options.body\n    }\n}\n\nfunction dynamicRequest(request: Request): Request {\n    return {\n        url: `https://google.com/?ketsu_dynamic=${encodeURIComponent(JSON.stringify(request))}`,\n        method: \"GET\",\n        headers: emptyKeyVal,\n        httpBody: undefined\n    }\n}\n\n// MARK: LAYOUT\n\n/**\n * Layout distribution options for organizing content views\n */\ntype Distributions =\n    | 'ultraWideFull' | 'ultraWide'\n    | 'wideFull' | 'wide' | 'wideStrechedFull' | 'WideStrechedFullDouble'\n    | 'wideStreched' | 'wideStrechedDouble' | 'wideStrechedFullList' | 'wideStrechedList'\n    | 'doublets' | 'doubletsDouble' | 'doubletsFull' | 'doubletsFullDouble'\n    | 'doubletsConstant' | 'doubletsDoubleConstant' | 'doubletsFullConstant' | 'doubletsFullDoubleConstant'\n    | 'longDoublets' | 'longDoubletsDouble' | 'longDoubletsFull' | 'longDoubletsFullDouble'\n    | 'longDoubletsConstant' | 'longDoubletsDoubleConstant' | 'longDoubletsFullConstant' | 'longDoubletsFullDoubleConstant'\n    | 'triplets' | 'tripletsDouble' | 'tripletsFull' | 'tripletsFullDouble'\n    | 'tripletsConstant' | 'tripletsDoubleConstant' | 'tripletsFullConstant' | 'tripletsFullDoubleConstant'\n    | 'longTriplets' | 'longTripletsDouble' | 'longTripletsFull' | 'longTripletsFullDouble'\n    | 'longTripletsConstant' | 'longTripletsDoubleConstant' | 'longTripletsFullConstant' | 'longTripletsFullDoubleConstant';\n\n/**\n * Visual design styles for content cells\n */\ntype Designs =\n    | 'Special1' | 'Special2' | 'Special3' | 'CELLHelperText'\n    | 'small1' | 'small2'\n    | 'normal1' | 'normal2' | 'normal3' | 'normal4' | 'normal5' | 'normal7'\n    | 'wide1' | 'wide2' | 'wide3' | 'wide4' | 'wide5' | 'wide6' | 'wide7' | 'wide8' | 'wide9' | 'wide10' | 'wide11';\n\n\nconst defaultImage = request(\"https://www.shutterstock.com/image-vector/default-ui-image-placeholder-wireframes-600nw-1037719192.jpg\")\nconst defaultRequest = request(\"https://www.google.com/\")\n\n/**\n * Container for organizing multiple content views\n */\ninterface ViewsHolder {\n    /** Section title */\n    title: string;\n    /** Visual design style for the views */\n    design: Designs;\n    /** Layout distribution pattern */\n    distribution: Distributions;\n    /** Orientation of the layout */\n    orientation: \"vertical\" | \"horizontal\";\n    /** Array of content views */\n    views: View[];\n}\n\ntype _ViewsHolder = Prettify<Partial<ViewsHolder>>\n\nexport function viewsHolder(h: _ViewsHolder): ViewsHolder {\n    return {\n        cellDesing: h.design || \"wide5\",\n        defaultLayout: h.distribution || \"wideStrechedFullList\",\n        orientation: h.orientation || \"vertical\",\n        section: {\n            sectionName: h.title || \"\",\n            separator: true\n        },\n        paging: \"leading\",\n        data: h.views || [],\n        layout: undefined,\n    } as any\n}\n\n\n/**\n * Individual content view item\n */\ninterface View {\n    /** Navigation link for the view */\n    link: Request;\n    /** Image/thumbnail for the view */\n    image: Request;\n    /** Primary title text */\n    title: string;\n    /** Description text */\n    description: string;\n    /** Additional field 1 */\n    field1: string;\n    /** Additional field 2 */\n    field2: string;\n    /** Additional field 3 */\n    field3: string;\n    /** Additional field 4 */\n    field4: string;\n    /** Whether this view represents a chapter */\n    isChapter: boolean;\n    /** Whether to open in webview */\n    openInWebView: boolean;\n}\n\n\n/**\n * Creates a views holder container with default values\n * @param h - Partial views holder configuration\n * @returns Complete ViewsHolder object with defaults applied\n * \n * @example\n * const holder = viewsHolder({\n *   title: \"Popular Movies\",\n *   design: \"wide5\",\n *   distribution: \"doublets\",\n *   views: [view1, view2, view3]\n * });\n */\ntype _View = Prettify<Partial<Omit<View, \"openInWebView\" | \"isChapter\">>>\n\n/**\n * Creates a content view with default values\n * @param v - Partial view configuration\n * @returns Complete View object with defaults applied\n * \n * @example\n * const movieView = view({\n *   title: \"The Matrix\",\n *   description: \"A computer hacker learns about reality\",\n *   image: request(\"https://example.com/matrix.jpg\"),\n *   link: request(\"https://example.com/matrix\")\n * });\n */\nexport function view(v: _View): View {\n    return {\n        link: dynamicRequest(v.link || defaultRequest),\n        image: v.image || defaultImage,\n        title: v.title || \"\",\n        description: v.description || \"\",\n        field1: v.field1 || \"\",\n        field2: v.field2 || \"\",\n        field3: v.field3 || \"\",\n        field4: v.field4 || \"\",\n        isChapter: false,\n        openInWebView: false\n    }\n}\n\n\n// MARK: MAINPAGE\n\n/**\n * Sets up the main page layout with the provided view holders\n * @param layout - Array of ViewsHolder objects to display on the main page\n * \n * @example\n * main([\n *   viewsHolder({ title: \"Featured\", views: featuredViews }),\n *   viewsHolder({ title: \"Popular\", views: popularViews })\n * ]);\n */\nexport function main(layout: ViewsHolder[]): void {\n    metadata().output = layout\n    finish()\n}\n\n// MARK: SEARCHPAGE\n\n/**\n * Sets up the search results page layout\n * @param layout - Array of ViewsHolder objects to display search results\n * \n * @example\n * search([\n *   viewsHolder({ title: \"Search Results\", views: searchResults })\n * ]);\n */\nexport function search(layout: ViewsHolder[]): void {\n    metadata().output = layout\n    finish()\n}\n\n/**\n * Search metadata information\n */\ninterface SearchMetadata {\n    /** Current search query */\n    searched: string;\n    /** Current page number (0-based) */\n    page: number;\n}\n\n/**\n * Retrieves current search metadata (query and page), must be used at the start of the search script.\n * @param test - Optional test metadata to override URL parsing\n * @returns Search metadata object\n * \n * @example\n * const { searched, page } = searchMetadata();\n * console.log(`Searching for: ${searched}, Page: ${page}`);\n */\nexport function searchMetadata(test?: Prettify<Partial<SearchMetadata>>): Prettify<SearchMetadata>{\n    let meta = metadata()\n    let searchMeta = store.get<SearchMetadata>(\"ketsu_search\")\n\n    if (!searchMeta && meta.request.url.includes(\"?ketsu_search=\")) {\n        let url = new URL(meta.request.url).searchParams\n        let searched = url.get(\"ketsu_search\") || \"\"\n        let page = parseInt(url.get(\"page\") || \"0\", 10)\n        searchMeta = {\n            searched: test?.searched ? test.searched : searched,\n            page: test?.page ? test.page : page\n        }\n        store.set(\"ketsu_search\", searchMeta)\n    }\n\n    return searchMeta || { searched: \"\", page: 0 }\n}\n\n// MARK: INFOPAGE\n/**\n * Chapter request configuration\n */\ninterface ChapterRequest {\n  /** Optional chapter name */\n  chapName?: string;\n  /** Navigation link for the chapter */\n  link: Request;\n  /** Whether to open in webview */\n  openInWebView: boolean;\n}\n\n/**\n * Options for creating chapter requests\n */\ninterface ChapterRequestOptions extends FetchOptions {\n  /** Chapter name */\n  name?: string;\n  /** Whether to open in webview */\n  openInWebView?: boolean;\n}\n\n/**\n * Creates a chapter request object\n * @param url - Chapter URL\n * @param options - Chapter configuration options\n * @returns ChapterRequest object\n * \n * @example\n * const chapter = chapterRequest(\"https://example.com/chapter1\", {\n *   name: \"Chapter 1: The Beginning\",\n *   openInWebView: false\n * });\n */\nexport function chapterRequest(url: string, options: Prettify<ChapterRequestOptions> = {}): ChapterRequest {\n    return {\n        chapName: options.name,\n        link: dynamicRequest(request(url, options)),\n        openInWebView: options.openInWebView ?? false\n    };\n}\n\n\n/**\n * Information page structure for detailed content view\n */\ninterface InfoPage {\n  /** Main image for the content */\n  image: Request;\n  /** Navigation link */\n  link: Request;\n  /** Content title */\n  title: string;\n  /** Content description */\n  description: string;\n  /** Array of genre tags */\n  genres: string[];\n  /** Additional field 1 */\n  field1: string;\n  /** Additional field 2 */\n  field2: string;\n  /** Additional field 3 */\n  field3: string;\n  /** Additional field 4 */\n  field4: string;\n  /** Array of available chapters */\n  chapters: ChapterRequest[];\n}\n\n\ntype _InfoPage = Prettify<Partial<InfoPage>>\n\n/**\n * Sets up an information/detail page\n * @param data - Partial info page configuration\n * \n * @example\n * info({\n *   title: \" Some title\",\n *   description: \"A high school chemistry teacher turned meth cook\",\n *   genres: [\"Drama\", \"Crime\", \"Thriller\"],\n *   chapters: [chapter1, chapter2, chapter3]\n * });\n */\nexport function info(data: _InfoPage): void {\n    let l: InfoPage = {\n        image: data.image || defaultImage,\n        link: data.link || metadata().request, \n        title: data.title || \"\",\n        description: data.description || \"\",\n        genres: data.genres || [],\n        field1: data.field1 || \"\",\n        field2: data.field2 || \"\",\n        field3: data.field3 || \"\",\n        field4: data.field4 || \"\",\n        chapters: data.chapters || []\n    }\n    metadata().output = l\n    finish()\n}\n\n// MARK: CHAPTERS \n\n/**\n * Chapter content with video support\n */\ninterface ChapterVideos {\n  videos?: {\n    /** Videos that need URL resolution */\n    needsResolver?: ResolverRequest[];\n    /** Direct video URLs */\n    rawVideo?: VideoRequest[];\n  };\n}\n\n/**\n * Chapter content with image support\n */\ninterface ChapterImages {\n  /** Array of image requests */\n  images?: Request[];\n}\n\n\n/**\n * Chapter content with text support\n */\ninterface ChapterText {\n  text?: {\n    /** Text content */\n    text: string;\n  };\n}\n\n\n/**\n * Combined chapter content interface\n */\ninterface Chapter extends ChapterVideos, ChapterImages, ChapterText {\n\n}\n\n/**\n * Sets up chapter content (videos, images, or text)\n * @param data - Chapter content data (images, videos, or text string)\n * \n * @example\n * // For image-based content (manga)\n * chapters([\n *   request(\"https://example.com/page1.jpg\"),\n *   request(\"https://example.com/page2.jpg\")\n * ]);\n * \n * @example\n * // For video content\n * chapters([\n *   videoRequest(\"https://example.com/video.mp4\"),\n *   resolverRequest(\"https://example.com/embed\")\n * ]);\n * \n * @example\n * // For text content\n * chapters(\"This is the chapter text content...\");\n */\nexport function chapters(data: Request[] | (VideoRequest | ResolverRequest)[] | string): void {\n    let output: Chapter = {\n        videos: undefined,\n        text: undefined,\n        images: undefined\n    };\n\n    if (!Array.isArray(data)) {\n        if (typeof data !== \"string\") {\n            throw new Error(\"Chapters type is wrong\")\n        }\n        output.text = { text: data };\n    }\n\n    if (Array.isArray(data) && data.some((k) => (\"url\" in k))) {\n        output.images = data as Request[]\n    } else if (Array.isArray(data)) {\n\n        output.videos = {\n            needsResolver: [],\n            rawVideo: []\n        }\n\n        data.forEach((v) => \"video\" in v ? output!.videos!.rawVideo!.push(v) : output!.videos!.needsResolver!.push(v as any))\n\n    }\n\n    metadata().output = output;\n    finish();\n}\n\n\n// MARK: RESOLVE\n\n/**\n * Returns the video resolved from the embeded website.\n * @param video - VideoRequest object to resolve\n * \n * @example\n * const resolvedVideo = videoRequest(\"https://cdn.example.com/video.mp4\");\n * resolver(resolvedVideo);\n */\nexport function resolver(video: VideoRequest): void {\n    metadata().output = video;\n    finish();\n}\n\n/**\n * Resolver request options\n */\ninterface ResolverRequestOptions extends FetchOptions {\n  /** Unique resolver identifier, example https://streamwebsite.com/..  \n   * The id would be: STREAMWEBSITE this is automatically extracted if left unedfined.*/\n  resolverID?: string;\n}\n\n/**\n * Video resolver request for extracting video URLs\n */\ninterface ResolverRequest {\n  /** Unique resolver identifier */\n  resolverIdentifier: string;\n  /** Request to the resolver endpoint */\n  link: Request;\n}\n\n\n/**\n * Creates a resolver request for extracting video URLs from embed pages\n * @param url - URL to the video resolver/embed page\n * @param options - Resolver configuration options\n * @returns ResolverRequest object\n * \n * @example\n * const resolver = resolverRequest(\"https://streamwebsite.com/video123\", {\n *   resolverID: \"STREAMWEBSITE\" // \n * });\n */\nexport function resolverRequest(url: string, options?: Prettify<ResolverRequestOptions>): ResolverRequest {\n    return {\n        link: dynamicRequest(request(url, options)),\n        resolverIdentifier: options?.resolverID || \"\"\n    }\n}\n\n/**\n * Subtitle request options\n */\ninterface SubsRequestOptions extends FetchOptions {\n  /** Subtitle language */\n  language?: string;\n}\n\n/**\n * Subtitle request configuration\n */\ninterface SubsRequest {\n  /** Request to subtitle file */\n  link: Request;\n  /** Subtitle language */\n  language: string;\n}\n\n/**\n * Creates a subtitle request\n * @param url - URL to subtitle file\n * @param options - Subtitle configuration options\n * @returns SubsRequest object\n * \n * @example\n * const subtitles = subsRequest(\"https://example.com/subs.vtt\", {\n *   language: \"English\"\n * });\n */\nexport function subsRequest(url: string, options?: Prettify<SubsRequestOptions>): SubsRequest {\n    return {\n        link: request(url, options),\n        language: options?.language || \"unknown\"\n    }\n}\n\n/**\n * Video request options\n */\ninterface VideoRequestOptions extends FetchOptions {\n  /** Video quality identifier */\n  quality?: string;\n  /** Array of subtitle requests */\n  subs?: SubsRequest[];\n}\n\n/**\n * Internal video request structure\n */\ninterface _VideoRequest {\n  /** Request to video file */\n  videoLink: Request;\n  /** Video quality identifier */\n  videoQuality: string;\n}\n/**\n * Complete video request with subtitles\n */\ninterface VideoRequest extends VideoRequestOptions {\n  /** Array of video sources */\n  video: _VideoRequest[];\n  /** Array of subtitle requests */\n  subs?: SubsRequest[];\n}\n\n\n/**\n * Creates a video request with quality and subtitle options\n * @param url - Direct video URL\n * @param options - Video configuration options\n * @returns VideoRequest object\n * \n * @example\n * const video = videoRequest(\"https://example.com/video.mp4\", {\n *   quality: \"1080p\",\n *   subs: [\n *     subsRequest(\"https://example.com/en.vtt\", { language: \"English\" }),\n *     subsRequest(\"https://example.com/es.vtt\", { language: \"Spanish\" })\n *   ]\n * });\n */\nexport function videoRequest(url: string, options?: VideoRequestOptions): VideoRequest {\n    return {\n        video: [{\n            videoLink: request(url, options),\n            videoQuality: options?.quality || \"auto\"\n        }],\n        subs: options?.subs\n    }\n}\n\n\n// MARK: METADATA\n\ninterface KeyValue {\n    key: string;\n    value: string;\n}\n\ninterface Request {\n    url: string;\n    method: FetchMethods;\n    headers: KeyValue[];\n    httpBody?: string\n}\n\ninterface JavascriptConfig {\n    loadInWebView: boolean;\n    javaScript: string;\n    removeJavascript: boolean;\n}\n\ninterface Command {\n    commandName: string;\n    params: KeyValue[];\n}\n\ninterface Extra {\n    commands: Command[];\n    extraInfo: KeyValue[];\n}\n\ninterface Global {\n    cookies: KeyValue[];\n    headers: KeyValue[];\n    variables: KeyValue[];\n}\n\ninterface ResponseInfo {\n    headers: KeyValue[];\n    responseUrl: string;\n    httpBody: string;\n}\n\ninterface KetsuMetadata {\n    request: Request;\n    separator: string;\n    javascriptConfig: JavascriptConfig;\n    extra: Extra;\n    global: Global;\n    responseInfo: ResponseInfo;\n    output: any\n}\n\nvar _metadata: KetsuMetadata | undefined = undefined\n\nfunction metadata(): KetsuMetadata {\n\n    if (!_metadata) {\n        const savedData = document.getElementById('ketsu-final-data');\n        _metadata = JSON.parse(savedData?.textContent || \"\")\n    }\n\n    return _metadata as KetsuMetadata\n}\n\n// MARK: Finish\n\nfunction finish(): void {\n    const savedData = document.getElementById('ketsu-final-data');\n    _metadata ? (savedData!.textContent = JSON.stringify(_metadata)) : (undefined)\n    _logs.forEach((l) => action(\"KETSU_LOG\", l))\n    action(\"EXECUTE_KETSU_ASYNC\")\n    throw new Error()\n}\n\n// MARK: STORE\n\n\n\n/**\n * Key-value storage interface\n */\ninterface Store<T extends string = string> {\n  /**\n   * Stores a value with the given key\n   * @param key - Storage key\n   * @param val - Value to store\n   * @param persist - Whether to persist across scripts\n   */\n  set: (key: T, val: any, persist?: boolean) => void;\n  \n  /**\n   * Retrieves a value by key\n   * @param key - Storage key\n   * @returns Stored value or undefined\n   */\n  get: <R>(key: T) => R | undefined;\n  \n  /**\n   * Checks if a key exists in storage\n   * @param key - Storage key\n   * @returns True if key exists\n   */\n  has: (key: T) => boolean;\n}\n\n\nconst _store: Record<string, string> = {\n    ...[...metadata().extra.extraInfo, ...metadata().global.variables].reduce((acc, val) => {\n        acc[val.key] = val.value\n        return acc\n    }, {} as Record<string, string>)\n}\n\n/**\n * Global storage instance for persisting data\n * \n * @example\n * // Store data\n * store.set(\"user_preferences\", { theme: \"dark\" });\n * \n * // Retrieve data\n * const prefs = store.get(\"user_preferences\");\n * \n * // Check if key exists\n * if (store.has(\"user_preferences\")) {\n *   // Key exists\n * }\n */\nexport const store: Store = {\n    set: (key, value, persist = false) => {\n        let val = encodeURIComponent(JSON.stringify({ value: value }))\n        persist ? setCommand(\"persistant\", key, val) : setExtraInfo(key, val)\n    },\n    get: (key) => {\n        let val: any = undefined\n        try {\n            val = JSON.parse(decodeURIComponent(_store[key])).value\n        } catch {\n            log(`key: ${key} not found in the store.`)\n        }\n        return val\n    },\n    has: (key) => (key in _store)\n}\n\nfunction setExtraInfo(key: string, value: string): void {\n    let meta = metadata()\n    let kv = meta.extra.extraInfo.find((k) => k.key === key)\n    if (!kv) {\n        kv = {\n            key: \"\",\n            value: \"\"\n        }\n        meta.extra.extraInfo.push(kv)\n    }\n    kv.key = key\n    kv.value = value\n}\n\n\n// MARK: COMMAND\ntype Commands = \"persistant\" | \"variable\" | \"cookie\" | \"header\" | \"helperFunction\" | (string & {})\nfunction setCommand(name: Commands, key: string, value: string): void {\n    let meta = metadata()\n    let command = meta.extra.commands.find((c) => c.commandName == name)\n    if (!command) {\n        command = {\n            commandName: name,\n            params: []\n        }\n        meta.extra.commands.push(command)\n    }\n    command.params.push({ key, value })\n}\n\n\n// MARK: ACTIONS\ntype Actions = \"EXECUTE_KETSU_ASYNC\" | \"KETSU_LOG\" | \"KETSU_MSG\"\nfunction action(name: Actions, val: string = \"\"): void {\n    if (\"webkit\" in window) {\n        (window as any).webkit.messageHandlers[name].postMessage(val);\n    } else if (name === \"KETSU_LOG\") {\n        console.log(val)\n    }\n}\n\n\n// MARK: LOGS\nlet _logs: string[] = []\n\n/**\n * Logs messages for debugging purposes\n * @param args - Values to log\n * \n * @example\n * log(\"Debug message\", { data: \"example\" });\n * log(\"User action:\", userAction, \"Result:\", result);\n */\nexport function log(...args: any[]): void {\n    const stringifiedArgs = args.map(arg => stringify(arg)).join('\\n\\n');\n    _logs.push(stringifiedArgs)\n}\n\nfunction stringify(value: any): string {\n    // Primitives\n    if (value === null) return 'null';\n    if (value === undefined) return 'undefined';\n    if (typeof value === 'string') return value;\n    if (typeof value === 'number' || typeof value === 'boolean') return String(value);\n\n    // Functions\n    if (typeof value === 'function') {\n        return `[Function: ${value.name || 'anonymous'}]`;\n    }\n\n    // Errors\n    if (value instanceof Error) {\n        return `${value.name}: ${value.message}`;\n    }\n\n    // Everything else - just stringify with pretty print\n    try {\n        return JSON.stringify(value, (key, val) => {\n            if (typeof val === 'function') {\n                return `[Function: ${val.name || 'anonymous'}]`;\n            }\n            if (val instanceof Error) {\n                return `${val.name}: ${val.message}`;\n            }\n            return val;\n        }, 2);\n    } catch (e) {\n        return `[${value.constructor?.name || 'Object'}]`;\n    }\n}","type":"typescript","compiled":false,"status":true,"shared":true,"line":603}},"fileIndexPath":[0,0]},"shared":{"compiledJS":"","fileType":"shared","fileSection":"Shared","fileID":925957622,"fileName":"shared.ts","files":{"note":{"data":"","name":"Note Editor","status":false,"viewerStatus":true},"code":{"route":["compiledJS"],"name":"Code Editor","data":"import * as core from \"./core\"\r\n\r\nexport function extractJsonString(text : string) {\r\n    // Match the first {...} or [...] block (non-greedy)\r\n    const match = text.match(/({[\\s\\S]*}|\\[[\\s\\S]*\\])/);\r\n    return match ? JSON.parse(match[0]) : null;\r\n}\r\n\r\n/**\r\n * Given an array of chapter entries, returns only the preferred group for each chap.\r\n * @param {Array} chapters - Array of chapter objects with 'chap' and 'group_name'.\r\n * @param {Array} preferredGroups - Array of group names in order of preference.\r\n * @returns {Array} Filtered array with only preferred group per chap.\r\n */\r\nexport function filterChaptersByPreferredGroup(chapters : Array<Record<string, any>>, preferredGroups : Array<string>) {\r\n    // Group chapters by chap number\r\n    const chapMap = new Map();\r\n    for (const entry of chapters) {\r\n        const chapNum = entry.chap;\r\n        if (!chapMap.has(chapNum)) chapMap.set(chapNum, []);\r\n        chapMap.get(chapNum).push(entry);\r\n    }\r\n\r\n    // For each chap, pick the preferred group\r\n    const result = [];\r\n    for (const [chapNum, groupEntries] of chapMap.entries()) {\r\n        // Sort by preferredGroups order\r\n        groupEntries.sort((a: any, b: any) => {\r\n            const aIdx = preferredGroups.indexOf(a.group_name);\r\n            const bIdx = preferredGroups.indexOf(b.group_name);\r\n            return (aIdx === -1 ? Infinity : aIdx) - (bIdx === -1 ? Infinity : bIdx);\r\n        });\r\n        result.push(groupEntries[0]); // Pick the top-ranked group\r\n    }\r\n    return result;\r\n}\r\n\r\nexport function ImageService(data: string) {\r\n    return core.request('https://meo.comick.pictures/' + data);\r\n}\r\n\r\nexport function InfoService(data: string) {\r\n    return core.request(`https://comick.io/comic/${data}?lang=en`);\r\n}","type":"typescript","compiled":false,"status":true,"shared":true,"line":44}},"fileIndexPath":[1,0]}}